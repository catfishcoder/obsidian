# 数据结构与算法

## 0 . 重点

- 每个数据结构的抽象数据类型定义和实现

## 1.绪论

### 1.概念

- **数据结构**是相互之间存在一种或多种特定关系的数据元素的集合

- **算法**是针对特定问题求解步骤的一种描述,是指令的有限序列

-   数据结构是指一组数据的存储结构,算法是操作数据的一组方法

-   数据结构包括:逻辑结构,存储结构和数据的运算

    -   逻辑结构:线性表, 栈和队列, 串, 树, 图

    -   存储结构:顺序存储, 链式存储

    -   数据的运算: 包括运算的定义和实现, 运算的定义是针对逻辑结构, 运算的实现是针对存储结构的,包括创建, 销毁, 增删改查等

-   数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。

-   10个数据结构：数组、链表、栈、队列、散列表、二叉 树、堆、跳表、图、Trie树;

-   10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

-   所有链式结构的实现都有带头节点和不带头节点的实现


### 2.复杂度分析

> 事后统计法依赖测试环境且受数据规模的影响 常用的为大O复杂度表示法

#### 1.时间复杂度分析

**大O阶复杂度表示法:** T(n) = O(f(n))

-   算法时间开销T(n)与问题规模n的关系,

-   **大O时间复杂度实际上并不具体表示代码真正的执行时间,而是表示代码执行时间随数据规模增长的变化趋势, 所以函数中不影响增长趋势的量都可以忽略**

-   两个法则

    -   加法规则:总复杂度等于量级最大的那行代码的复杂度

    -   乘法规则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

-   几种常见的时间复杂度

    -   常量阶O(1), 线性阶O(n), 指数阶O(n^2), 对数阶O(\log n), 阶乘阶O(n!), 线性对数阶O(n \log n), 平方阶, 立方阶,,,

    -   对数阶O(\log n), 的代码表示:
        ```C++
        
         i = 1;
         while(i <= n){
          i = i * 2;
         } 					/时间复杂度为O(log~2~n)
        ```
    -   O(1) < O(\log_2 n) < O(n) < O(nlog_2 n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < o(n^n)


#### 2.空间复杂度分析

-   普通程序

    -   找到所占空间大小与问题规模相关的变量

    -   分析所占空间x与问题规模n的关系 x = f(n)

    -   x的数量级就是算法空间复杂度S(n)

-   递归程序

    -   找到递归程序的深度x与问题规模n的关系

-   适用加法、乘法规则


## 2.线性表(linear line)

#### 1. 线性表的逻辑结构

#### 1. 线性表的定义

> 线性表是具有相同**数据类型**的n个**数据元素**的有限序列, 其中n是表长, n=0时是空表
>
> L = (a_1, a_2, ... a_i, a_{i+1}, ... a_n )

几个概念:

-   a_i 是线性表中的第i个元素, 表示线性表中的位序, 位序从1开始, 数组从0开始

-   a_1 是表头元素, a_n 是表尾元素

-   除第一个元素外,每个元素有且仅有一个直接前驱,除最后一个元素外, 每个元素有且仅有一个直接后继


#### 2.线性表的操作

-   InitList(&L) : 初始化表, 构造一个空的线性表L, 分配内存空间

-   DestroyList(&L): 销毁操作, 销毁线性表, 并释放线性表L所占用的内存空间

-   ListInsert(&L, i, e): 插入操作, 在表L的第i个位置插入指定元素e

-   ListDelete(&L, i &e): 删除操作, 删除表L中第i个位置的元素, 并用e返回删除元素的值

-   LocateElem(L, e): 按值查找操作, 在表L中查找具有给定关键字值的元素

-   GetElem(L, i): 按位查找操作, 获取表L中第i个位置的元素的值


**其他操作**

-   Length(L): 求表长, 返回线性表的长度, 即L中数据元素的个数

-   PrintList(L): 输出操作, 按前后顺序输出线性表L中所有元素的值

-   Empty(L): 判空操作, 若L为空表返回true, 否则返回false


<!--对数据的操作大致为: 创建, 销毁, 增删改查 -->

### 2. 线性表的存储结构(实现)

#### 1.顺序表

> 用顺序存储的方式实现线性表
>
> 顺序存储: 把逻辑上相邻的元素存储在物理位置也相邻的存储单元中, 元素之间的关系由存储单元的邻近关系来体现

-   **顺序表的特点**


1.  随机访问, 即可以在O(1)的时间内找到第i个元素
2.  存储密度高,每个节点只存储数据元素
3.  拓展容量不方便
4.  插入删除操作不方便,需要移动大量元素
6.  顺序表的动态分配
```C++
     void InitList(Sqlist &L){ //动态分配
      L.data = (int *)malloc(sizeof(int) * InitSize);
      L.MaxSize = InitSize;
      L.length = 0;

      for (int i = 0; i < 5; i++)
      L.data[i] = i;
      L.length = 5;
     }
```
7.  顺序表的静态分配
```C++
     void InitList(Sqlist &L){
      for (int i = 0; i < MaxSize; i++)
      L.data[i] = 0;
      L.length = 0;
     }
```
8.  顺序表的插入操作
```
     bool ListInsert(Sqlist &L, int i, int e){
      if (i < 1 || i > L.length +1)
      return false;
      if (L.length >= InitSize)
      return false;
      for (int j = L.length ; j >= i ; j--)
      L.data[j] = L.data[j - 1];
      L.data[i - 1] = e;
      L.length ++;

      return true;
     }
```
9.  顺序表的删除操作
```
     bool ListDelete(Sqlist &L, int i, int &e){
      if (i < 1 || i > L.length)
      return false;
      e = L.data[e -1];
      for (int  j  = i ; j < L.length; j++)
      {
      L.data[j -1] = L.data[j];
      }
      L.length--;
      return true;
     }
```
10.  顺序表的查找操作
```
     int GetElem(Sqlist L, int i){
      return L.data[i - 1];
     } //按位查找
     int LocateElem(Sqlist L, int e){
      for (int i = 0; i < L.length; i++)
      if (L.data[i] == e)
      return i + 1;
      return 0;
     } //按值查找
```

#### 2.链表

##### 1. 单链表[[SingleLinkList]]

> 定义: 通过一组任意的存储单元来存储线性表中的数据元素, 为了建立数据元素之间的线性关系, 对每一个链表节点除了存放数据元素自身的信息外, 还需要存放一个指向其后继的指针;

1.  利用结构体来创建单链表
```
     typedef struct LNode{
      int data;
      struct LNode *next;
     }LNode, *LinkList;
```
    -   强调这是一个单链表使用 **LinkList**
    
    -   强调这是一个节点使用 **LNode**

2.  初始化单链表
```
     bool InitList(LinkList &L){
      L = nullptr;
      return true;
     } //不带头节点
     bool InitList(LinkList &L){
      L = (LNode *)malloc(sizeof(LNode));
      if (L==NULL)
      return false;
      L->next = NULL;
      return true;
     } //带头节点
```
3.  单链表的插入


##### 2.双链表

##### 3. 循环链表

##### 4. 静态链表

#### 3. 顺序表和链表

##### 1. 逻辑结构

两者都属于线性结构

##### 2. 存储结构

-   顺序表用顺序存储来实现,

    -   优点:支持随机存取, 存储密度高

    -   缺点: 大片连续空间分配不方便, 改变容量不方便

-   链表用链式存储实现

    -   优点:离散的小空间分配方便, 改变容量方便

    -   缺点: 不支持随机存取, 存储密度低


##### 3. 基本运算

> 基本操作:创建, 销毁, 增加, 删除 ,更改, 查找

1.  顺序表

    1.  创建:需要预先分配大片的连续内存空间,如果分配空间过小,则之后不方便扩展容量；如果分配容量过大,则浪费内存资源

    2.  销毁:修改length = 0；如果是静态分配, 系统会自动回收空间,如果是动态分配,需要手动free

    3.  增加, 删除: 插入/删除元素需要将后续元素都向后移,时间复杂度为O(n), 时间开销主要来自移动元素

    4.  查找:按位查找O(1), 按值查找O(n), 若表内元素时有序的,那么可以在O(\log_2 n) 时间内找到


    <!--malloc申请的内存空间,最后都要手动释放掉-->

2.  链表

    1.  创建:只需要分配一个头节点, 之后方便拓展

    2.  销毁:依次删除各个节点(free)

    3.  增加, 删除: 只需要修改指针即可, 时间复杂度O(n), 时间开销主要来自查找目标元素

    4.  查找: 按位查找/按值查找 O(n)


## 3. 栈和队列

> 只允许在一端进行插入或者删除操作的线性表
> 操作受限的线性表
### 1.栈

#### 1.概念

-   空栈:没有元素的栈称为空栈;

-   栈顶:允许插入和删除的一端;

-   栈底:不允许插入和删除的一端

-   特点:先进栈的元素最后出来, 最后进栈的元素最先出,栈的插入删除只能在栈顶的一端进行

#### 2. 顺序栈

> 顺序存储, 用静态数组实现, 并需要记录栈顶指针

##### 1. 逻辑结构
-   InitStack(&s): 初始化栈, 构造一个空栈S, 分配内存空间
-   DestoryStack(&S): 销毁栈, 销毁并释放栈S所占用的内存空间
-   Push(&S, x): 进栈, 若栈S未满, 则将x加入使其成为新栈顶
-   Pop(&S, &x): 出栈, 若栈S非空, 则弹出栈顶元素, 并用x返回
-   GetTop(s, &x): 读取栈顶元素, 若栈顶非空, 则用x返回栈顶元素

##### 2. 存储结构
[[SequenceStack]]

**共享栈**

> 顺序栈的空间在初始化之后就是固定的了, 如果分配的小, 空间不够, 分配的大,会造成内存空间的浪费

定义栈时创建两个栈顶指针, 一个指向数组的起始位置, 一个指向数组的终点位置, 在逻辑上实现了两个栈

#### 3. 链栈

[[LinkStack]]

> 类似与单链表(运算受限的单链表),不过只能在头节点之后进行插入或者删除操作
- 注意
	- 链表的头指针就是栈底
	- 不需要头节点
	- 基本不存在栈满的情况
	- 空栈相当于头指针指向空
	- 插入和删除仅在栈顶处执行

#### 4. 栈与递归
- 递归的定义:一个对象部分的包含它自己,或用它自己给自己定义,则称这个对象是递归的(函数调用其自身)

	1. 递归必须有一个结束条件
	2. 分治法求解递归的一般途径

		```C++
			void f(参数表){
				if(递归结束条件) 可直接求解项;		//基本项
				else f(较小的参数);				//归纳项
			}
		```
	3. 函数调用过程
		1. 调用前
			1. 将实参,返回地址传给被调函数
			2. 为被调函数的局部变量分配存储区
			3. 将控制转移被调函数的入口
		2. 调用结束
			1. 保存被调函数的执行结果
			2. 释放被调函数的数据区
			3. 依照被调用函数的返回地址将控制转移到调用函数
		3. 多个函数嵌套调用,先依次调用,然后依次返回. 最后调用的函数最先返回,
		4. 函数调用会分配内存空间, 函数的嵌套调用会占用大量内存空间
- 递归工作栈: 递归程序执行时需要系统提供栈来实现
- 递归优缺点
	- 优点:结构清晰,程序易读
	- 缺点:每次调用都要生成工作记录, 保存状态信息, 入栈. 返回时要出栈, 恢复状态信息. 时间开销大

##### 1.括号匹配问题

> 依次扫描所有字符, 遇到左括号入栈, 遇到右括号则弹出栈顶元素检查是否匹配
> 匹配失败情况:左括号单身, 右括号单身, 匹配失败

##### 2.表达式求值问题

符号入栈--> 判断是否为运算符

--> 否 --> 入栈 --> 继续读下一个符号 -- >判断是否为运算符

--> 是--> 将前两个操作数弹出并运算将新数入栈

> 三种表达式: 中缀表达式, 后缀表达式, 前缀表达式

###### 1.中缀表达式转后缀表达式

1.  手算

    1.  确定中缀表达式中各个运算符的运算顺序
    2.  选择下一个运算符, 按照[左操作数, 右操作数, 运算符]的方式组合成一个新的操作数
    3.  如果还有操作数没有处理, 就继续2
    4.  左优先原则: 只要左边的运算符能够优先运算,就优先算左边的
2.  机算
    1.  从左往右扫描下一个元素, 直到处理完所有元素
    2.  若扫描到操作数则压入栈, 并回到1, 够则执行3
    3.  若扫描到操作符, 则弹出两个栈顶元素(先弹出来的是右操作数), 否则执行相应运算, 运算结果压入栈顶, 回到1

###### 2. 中缀表达式转前缀表达式
1.  手算
    1.  确定中缀表达式中各个运算符的运算顺序
    2.  选择下一个运算符, 按照[运算符, 左操作数, 右操作数,]的方式组合成一个新的操作数
    3.  如果还有操作数没有处理, 就继续2
    4.  右优先原则,: 只要右边的运算符能先运算, 就优先算右边的
2.  机算
    1.  从右往左扫描下一个元素, 直到处理完所有元素
    2.  若扫描到操作数则压入栈, 并回到1, 够则执行3
    3.  若扫描到操作符, 则弹出两个栈顶元素(先弹出来的是左操作数), 否则执行相应运算, 运算结果压入栈顶, 回到1

### 2.队列

> 只允许在一端进行插入,在另一端进行删除的线性表

#### 1. 概念
-   队尾:允许插入的一端
-   队头:允许删除的一端
-   运算规则:只能在队首队尾进行运算, 原则:(FIFO)先进先出
-  常用的为**循环顺序队列**
#### 2. 逻辑结构
-   InitQueue(&Q): 初始化队列, 构造一个空队列Q
-   DestoryQueue(&Q): 销毁队列, 销毁并释放队列Q所占用的内存空间
-   EnQueue(&Q, x): 入队, 若队列Q未满, 将x加入, 使之成为新的队尾
-   DeQueue(&Q, &x): 出队, 若队列Q非空, 删除队头元素, 并用x返回
-   GetQueue(Q, &x):读取队头元素, 若队列Q非空, 则将队头元素赋值给x

#### 3.存储结构
##### 1.队列的顺序存储结构
- 代码: [[SequenceQueue]]
- 循环队列代码:[[SequenceQueue_loop]]

	1. 创建, 销毁,出队 见代码
	   -   关键代码`(Q.rear+1)%MaxSize == Q.front`

			-   解释:队列是一种从一端进 另一端出的线性表, 只要整个队列空间没有被占满, 就可以往里添加元素.整个队列可以被循环利用,这个过程称为循环队列
			-   引用取模操作来实现循环插入, 模运算将无限的整数域映射到有限的整数集合上,在逻辑上将存储空间变成环状
			-   小于MaxSize的值表示它本身, 大于Maxsize的值会重新归零再计算,
			-   本行代码的含义是:判断队尾指针指向的下一个位置是不是队首, 这样判断会造成最后一个位置闲置
		- 关键代码`Q.rear = (Q.rear + 1)%MaxSize`
			-   接上一段解释, 本行代码表示队尾指针指向队列的下一个位置, 是一种循环指向
		- 代码`(rear + MaxSize - front)%MaxSize`: 求队列元素个数
	2. 判空, 判满

		-   方法一:队尾指针的下一个位置是队头`(Q.rear+1)%MaxSize == Q.front`, 缺点就是最后一个位置被空置了,*此时rear的指向是队尾元素的下一个位置*
		-   方法二:初始化时添加一个`size`元素, 每次入队`size+1`每次出队`size-1`,最后比较size与MaxSize的值
		-   方法三:初始化时添加一个`tag`元素, 每次入队时将`tag`置为1, 每次出队时将`tag`置为0
			解释:队头指针和队尾指针相等时,有两种情况, 队满或者队空. 如果是入队导致两者相等,则队满, 如果是出队导致两者相等, 则队空;
- 其他问题
    -   队尾指针的指向:队尾指针可以指向队尾元素的后一个位置,也可以指向队尾元素,**默认为指向队尾元素的下一个位置**
        -   指向队尾元素时,
            -   初始化时需要将队尾指针指向存储空间的末位
            -   判空表示为: 队尾指针指向的下一个元素是队首
            -   判满表示: 需要将队尾指针的下一个元素位置弃置, 然后队尾指针指向的下一个元素的下一个元素为队首表示队满

##### 2.队列的链式存储结构

> 类似单链表, 不过只能在队尾插入, 在队首删除, 需要两个指针分别指向队首和队尾

代码: [[ListQueue]]
##### 3.双端队列

> 双端队列:只允许从两端插入删除的线性表
> 输入受限的双端队列:只允许从一端插入,两端删除的线性表
> 输出受限的双端队列:只允许从两端插入, 一端删除的线性表

-   考点:判断输出序列合法性,
    例题:若数据输入序列为1, 2, 3, 4. 则下列哪些输入序列时合法的
    提示:四位数共有24中排列组合, 卡特兰序列
## 4.串, 数组和广义表
### 4.1 串
> 内容受限的线性表
> **串(string)/字符串**: 由零个或多个字符组成的有限序列, 记为:`s = a1a2a3...an`

#### 4.1.1 概念
1. 子串:串中任意连续字符组成的子序列称为该串的子序列;
2. 主串:包含字串的串称为主串
3. 空格串:由空格组成的串
4. 字串位置:字串第一个字符在主串中的位置
5. 串相等:两个串长度相等且各个对应位置的字符也相等

#### 4.1.2 串的类型定义,存储结构及其运算
##### 4.1.2.1 串的抽象数据类型
>逻辑结构仍然是线性结构
>- StrAssign(&T,chars)					//串赋值
>- StrCompare(S,T)						//串比较
>- StrLength(S)								//求串长
>- Concat(&T,S1,S2)						//串连接
>- SubString(&Sub,S,pos,len)		//求子串
>- StrCopy(&T,S)							//串拷贝
>- StrEmpty(S)							 //串判空
>- CleanString(&S)					   //清空串
>- Index(S,T,pos)						//子串的位置
>- Replace(&S,T,V)						//串替换
>- StrInsert(&S,pos,T)				//字串插入
>- StrDelete(&S,pos,len)				//子串删除

##### 4.1.2.2 串的存储结构

1. 顺序存储: [[SqString]]
2. 链式存储: 用char来存储,存储密度太低,默认是按块来存储, 称为块链:[[ListString]]
3. 串的比较, 求串长, 连接, 拷贝, 替换, 字串的位置等,在C中都有函数来实现

##### 4.1.2.3 串的模式匹配算法
> 确定主串中所含子串(模式串)第一次出现的位置(定位)
> 应用:关键字查询
###### 1. BF算法
- (Brure-Force), 简单匹配算法, 采用穷举法的思路.
- 算法思路:从主串的每个字符开始依次与子串的字符进行匹配
- 主串S, 模式串T,主串用i计数, 模式串用j计数. 从主串S的第一个字符S.ch\[1\]与模式串T的第一个字符T.ch\[1\]进行匹配, 依次向下.
	- 如果字符匹配失败要进行==回溯==,令j=1, 继续比较下一个,直到i > S.length
		- 回溯: T从1位置移动到j，移动了j-1个长度，S也从1移动了j-1；S现在的位置是i，移动的长度是j-1, 用现在的位置i减去移动的长度**i-(j-1)**，再加1就是下一个位置。(i回到原位然后移到下一位)
		- 为了算法描述方便. 串从1开始计数,所以顺序串初始化时串的大小为MaxSize+1.
	- 如果j > T.length说明匹配成功, 返回 模式串在主串中的位置: i - T.length
- 算法思路:
	- 将主串的第pos个字符和模式串的第一个字符进行比较
		- 若相等,继续比较后续字符
		- 若不相等,从主串的下一个字符起,重新与模式串的第一个字符进行比较,直到主串中的一个连续子串与模式串相等,返回值为S中与T匹配的子序列第一个字符的序号,匹配成功. 否则匹配失败
- 算法描述

	```C++
	int Index_BF(SqString S, SqString T, int pos){
		int i = pos, j = 1;
		while(i <= S.length && j <= T.length){
			if(S.ch[i] == T.ch[j]){++i;++j;}
			else {i = i-(j-1)+1; j = 1;}
		}
		if(j > T.length) return i-T.length;
		else return 0;
	}
	
	```
- 时间复杂度分析: O(n*m)
###### 2.KMP算法 #KMP
- KMP算法是BF算法的一种优化,BF算法的时间开销主要来自主串中i的回溯, 模式串中j置1. 在KMP算法中i不再回溯,j也不必置1;

- 如果在匹配中出现字符不相等, 仅需将模式串向右移动**若干个字符**, 关键在于怎么移, 移多少

	- 知识点
		- 前缀:包含首位字符但不包含末位字符的子串
		- 后缀:包含末位字符但不包含首位字符的子串
		- next数组的定义:当主串与模式串的字符不匹配时,模式串要回退的位置
		- next\[j]: 其值,第j位字符前面j-1位字符组成的子串的前后缀重合字符数
	- 假设模式串在 j 的位置失配, 那么算法关键在于找到**相互匹配的公共前后缀**
		- 模式串从1到 j 中间的字符,从第一位开始除掉最后一位都是前缀,从第 j 位往前除掉第一位都是后缀, 前缀和后缀相等就是**相互匹配的公共前后缀**
		- 找到最大的相互匹配的公共前后缀,在此基础上加1, 称为第K+1位,
		- 将模式串中的第K+1位与失配的主串当前位进行比较

- (数据结构教材)当主串中的第i个字符与模式串中的第j个字符失配,主串中的第i个字符应该与模式串中的哪个字符进行比较

	- 假设此时应与模式串中的第k个字符进行比较, 则模式串中头k-1个字符必须与主串中第i个字符之前长度位k-1的子串相等, 则匹配从模式串中第k个字符与主串中第i个字符进行比较起继续进行
	- 令next\[j\]= k, 表示为模式串中第j个字符与主串中相应字符失配时, 在模式串中需要重新与主串中改字符进行比较的字符的位置,则next函数的定义为:
		- next\[j\] = 0   当j = 1时$$\begin{cases} max\{k|1<k<j, 且p_1 - p_{k-1} = p_{j-k+1}-p{j-1}\} \\ 1 其他\end{cases}$$
		- 如果匹配则i和j同时加1, 如果比较过程中产生失配时,指针i不变,指针j退回next\[j\]所指示的位置上重新比较并且当指针j退回零时,	指针i和j需同时加1,即主串的第i个字符和模式串的第一个字符不等,应从主串的第i+1个字符重新进行匹配
		- 关键在于==求next数组==

			```C++
				void get_next(SqString T, int& next[]){
					i = 1; next[1] = 0; j = 0;
					while(i<T.length){
						if(j == 0 || T.ch[i] == T.ch[j]){
							++i; ++j;
							next[i] = j;
						}
						else
							j = next[j];
					}
				}
			```


		- 算法详解: 先假设next\[j-1] = k1, 如果要求next\[j]的值, 那就需要比较ch\[j-1]与ch\[k1]是否相等,
			- 如果相等,那么next\[j] = k1 + 1; (k1的含义是指模式串的k1-1大小的前缀与ch\[j-1] 前面k1-1大小的后缀相等)
			- 如果不相等,  就看next\[k1],如果next\[k1] = k2, (k2表示ch\[k2] 前k2-1大小的后缀与模式串k2-1大小的前缀相等 ),说明ch\[j-1]前k2-1大小的后缀也和模式串k2-1大小的前缀相等
		    - 每次的不相等都会缩小模式串前缀的大小,直到前缀大小为0,判断成立, next\[++i] = ++j;
		    - ==总结:如果ch\[j]等于ch\[next\[j]], 那么next\[j+1] = next\[j] + 1, 如果不相等,那么next\[j+1]可能的次最大值为next\[next\[j]]+1, 依次类推求出next\[j+1]==

- KMP算法实现

```C++
	int Index_KMP(SqString S, SString T, int pos){
		i = pos; j = 1;
		while(i < S.length && j < T.length){
			if(j ==0 || S.ch[i] == T.ch[j]) {i++; j++;}
			else j = next[j];
		}

		if(j > T.length) return i - T.length;
		else return 0;
	}
```
- 时间复杂度:O(m+n)

### 4.2 数组

- 数组:按一定格式排列起来的具有相同类型的数据元素的集合
	- 一维数组:线性表中的元素为非结构的简单元素`数据类型 变量名[大小]
	- 二维数组:一维数组中的元素又是一维数组结构,`数据类型 变量名[行][列]`
- 数组特点:结构固定,定义后维数和维界不再改变
- 数组基本操作:除了结构的创建, 销毁之外, 只有取元素和修改元素值的操作
- 线性表结构是数组结构的特列,数组结构是线性表结构的拓展
- 数组的抽象数据类型定义(n维数组)
	- InitArray(&A,n, bound1, .... boundn)				//构造数组A
	- DestoryArray(&A)											//销毁数组A
	- Value(A,&e,index1, ... indexn)						//取数组元素值
	- Assign(A, &e, index1, ... indexn)					//给数组元素赋值

- 数组的存储结构

    > 一般用顺序存储结构来表示数组

    - 关键点:数组是多维的,但存储数据元素的内存单元地址是一维的, 如何将多维关系映射到一维关系上(i表示数组位序, a表示起始位置, L表示长度LOC(i)表示i的位置)
     - 一维数组:LOC(i) = a+i*L
    - 二维数组:LOC(i,j) = LOC(0,0) + (n*i+j)*L
     - 在C中多维数组以行序为主序

- **矩阵**

    > 一个由m*n个元素排列成的m行n列的表

    - 矩阵的常规存储:将矩阵描述为一个二维数组

     - 特点:1.可以对其元素进行随机存取,2. 矩阵的运算简单,存储密度为1

    - 不适宜常规存储的矩阵: 值相同的元素很多且呈某种规律分布, 零元素多

     - 矩阵的压缩存储:若多个数据元素的值都相同, 则只分配一个元素值的空间, 且零元素不占存储空间

    - 适宜压缩存储的矩阵:对称矩阵, 对角矩阵, 三角矩阵, 稀疏矩阵
         - 对称矩阵:
            	-  特点:aij = aji
            	-  存储方法:只存储上三角或者下三角(包括对角线 )的元素,占用n*(n+1)/2的存储空间
            	-  以行序为主序将元素存放在一维数组sa\[n*(n+1)/2]中, 则sa\[k]与矩阵元素aij存在一一对应关系k = i(i-1)/2 + j - 1 (i >= j)

        - 三角矩阵:
             - 特点: 对角线以下(或以上)的元素全部为常数c
            - 存储方法:重复元素c共享一个元素存储空间, 共占用n(n+1)/2 + 1个元素空间

        - 对角矩阵
             - 特点:在n\*n的方阵中, 所有非零元素都集中在以主对角线为中心的带装区域中,区域外值全为零
            - 用二维数组来存储对角矩阵, 每一个对角存放在二维数组的一行中

        - 稀疏矩阵:
             - 在m*n的矩阵中有t个非零元素, 令p = t/(m\*n) 当p <= 0.05时,称为稀疏矩阵, 稀疏矩阵的非零值非常少,

             - 存储方法: **三元组**, (i,j,$$a_{ij}$$)表示稀疏矩阵的一个元素, 将所有的元素存放在一个三元组顺序表中,为描述可靠,通常还要存储稀疏矩阵的信息(总行数,总列数,非零元素总个数)

                 - 三元组顺序表又称有序的双下标法, 优点:非零元在表中按行序有序存储,因此便于进行依次序的矩阵运算；缺点:不能随机存取,只能从头开始查找矩阵元素

            - 存储方法2: 十字链表(稀疏矩阵的链式存储结构): 在十字链表中, 矩阵中的每一个非零元素用一个节点表示,该节点除了(row, col, value)外, 还有两个域.

                - right:用于链接同一行的下一个非零元素
                - down: 用于链接同一列中的下一个非零元素

                ​    \| row \| col \| value\|

                ​    \|   down   \|    right  \|



### 4.3 广义表

> 列表Lists: 是n$$\geqslant$$0个元素的有限序列其中每一个$$a_i$$ 或者是原子, 或者是一个广义表
>
> 广义表是线性表的推广,与线性表的不同在于线性表中的$$a_i$$只限于单个元素, 广义表中的元素可以是单个元素(原子),也可以是一个广义表.
>
> 用大写字母表示广义表,小写字母表示原子

- 记作:LS=$$(a_1, a_2, ... a_n)$$, LS为表名, n为表长, $$a_i$$为表的元素
    - *表头:* 第一个元素$$a_1$$是表头,记作head(LS) = $$a_1$$
    - *表尾:* 除表头外的其他元素组成的表, 记作tail(LS) = $$(a_2, ..., a_n)$$ , 注意,表尾不是一个元素,而是一个子表
    - 广义表的长度定义为最外层所包含的元素个数
    - 广义表的深度定义为该广义表展开后所含括号的重数
    - 广义表可以为其他广义表共享,广义表可以是一个递归的表,递归表的深度是无穷值,长度是有限值



## 5. 树和二叉树

> 线性结构有唯一的前驱和后继,非线性结构不是,其中树有唯一的前驱,后继却不唯一

### 5.1 定义和基本术语

- **树**(Tree):是n(>=0)个结点的有限集,.在任意一颗非空树中:(1) 有且仅有一个称为根(root)的结点, (2)当n>1时,其余结点可分为m个互不相交的有限集,$$T_1, T_2, ... T_m$$ 其中每个集合本身又是一颗树,并且称为根的子树(SubTree),树是递归定义的.
    - 树的结点包含一个数据元素和若干指向其子树的分支, 节点拥有的子树数称为**结点的度**, 度为0的结点称为**叶子或终端结点**.度不为0的点称为**非终端节点或者分支结点**, 除根节点外, 分支结点也称内部节点,**树的度**是树内各节点度的大最大值,
    - 结点的子树的根称为该结点的**孩子**, 该结点称为孩子的**双亲**, 同一个双亲的孩子之间互称**兄弟**,结点的祖先是从根到该结点所经分支上的所有结点, 反之,以某结点为根的子树中任一结点都称为该结点的**子孙**,双亲在同一层的结点称为**堂兄弟**.
    - 结点的**层次**从根开始定义,根为第一层,根的孩子为第二层,.若某结点在l层, 则其子树的根就在l+1层,树中结点的最大层次称为树的**深度**
    - **有序树:** 树中结点的各子树从左到右是有次序的,则称为有序树,反之为无序树
    - **森林**: m(m>=0)棵互不相交的树的集合, 一颗树也可以是森林. 把根结点删了,树就变成了森林,给森林的各子树加上一个双亲结点,森林就变成了树

- 二叉树

    > 二叉树结构简单,规律性强, 运算容易实现,多叉树需要转换成二叉树进行运算

    - **二叉树(Binary Tree)** 是另一种树型结构,特点是每个结点至多有两棵子树,并且二叉树的子树有左右之分, 顺序不能随意颠倒.
    - ==二叉树不是树==:树是一种树型结构, 二叉树也是一种树型结构, 二叉树的结点即使只有一棵子树也要区分左右
    - **满二叉树:** 一棵深度为k且有$$2^k-1$$个结点的二叉树称为满二叉树,每一层的结点数为$$2^{k-1}$$, 终端结点全在最底层
    - **完全二叉树:** 对满二叉树自上到下,自左到右进行编号,对于一个深度为k,结点数为n的二叉树,其中的每一个结点都与深度为k编号为1-n的满二叉树的结点一一对应,称为完全二叉树, 简言之,完全二叉树就是满二叉树从后向前依次删除若干结点.
        - 满二叉树也是完全二叉树
        - 叶子结点只能分布在层次最大的两层上
        - 对任一结点,如果右子树的最大层次是i, 则左子树的最大层次就是i/i+1

### 5.2 树的应用案例

- 数据压缩案例:将数据文件转换成由0,1组成的二进制串,称之为编码
- 利用二叉树求解表达式的值:**第一运算数 运算符 第二运算数** , 用左子树表示第一个操作数, 双亲存放运算符, 右子树存放第二运算数

### 5.3 树和二叉树的抽象数据类型定义

> 树和二叉树类似,这里以二叉树表示

- CreateBiTree(&T, definition): 		//按definition构造二叉树
- PreOrderTraverse(T)                       //先序遍历T, 对每个结点访问一次
- InOrederTraverse(T)					   //中序遍历T,对每个结点访问一次
- PostOrderTraverse(T)                    //后序遍历T,对每个结点访问一次
- .......

### 5.4 二叉树的性质和存储结构

#### 5.4.1 二叉树的性质

- **性质1:** 在二叉树的第 i 层上至多有$$2^{i-1}$$个结点(i>=1)
- **性质2:** 深度为k的二叉树上至多有$$2^k-1$$个结点(k>=1)
- **性质3:** 对任何一个二叉树T,如果其终端结点数为$$n_0$$, 度为2的结点数为$$n_2$$ 则$$n_0 = n_2 +1$$
    - 总边数为B, 总结点数为n, 度为2的结点数为$$n_2$$, 度为1的结点数为$$n_1$$, 度为0的结点数为$$n_0$$, 则$$n=n_0+n_1+n_2$$
    - 总边数B从下往上算为$$B = n-1$$ , 从上往下算为$$B=n_2*2+n_1*1$$
    - 左右相等求得$$n_0 = n_2 +1$$
- **性质4:** 具有n个结点的完全二叉树的深度为$$\llcorner log_2 n\lrcorner +1$$,(括号表示向下取整)
- **性质5:** 如果对一棵n个结点的完全二叉树(深度为$$\llcorner log_2 n\lrcorner+1$$),的结点从左到右,从上到下编号,则对任意结点i有:
    1. 如果i=1, 则结点i是二叉树的根,无双亲,如果i>1, 则其双亲结点为$$\llcorner i/2\lrcorner$$
    2. 如果2i>n, 则结点i为叶子结点,无左孩子,否则其左孩子是结点2i
    3. 如果2i+1>n, 则结点无右孩子, 否则, 其右孩子是结点2i+1

#### 5.4.2 二叉树的存储结构

1. 顺序存储结构

    > 存储方式:用数组存储,
    >
    > 实现:按满二叉树的结点层次编号(从0开始),按位置存放二叉树中的数据元素, 二叉树空的位置在数组中做标记(比如置0),

    1. 创建二叉树

        ```C++
        #define MaxSize 100
        typedef ElemType SqBiTree[MaxSize];
        SqBiTree bt;
        ```

    2. 二叉树的顺序存储优缺点

        1. 对于深度为k,且只有k个结点的单枝树比较浪费,适合存放满二叉树和完全二叉树

2. 链式存储结构

    > 二叉树的结点由一个数据元素和分别指向其左右子树的两个分支组成, 所以二叉树链表中的结点包含三个域, 两个指针域,一个数据域.

    1. 初始化

        ```C++
        //包含两个孩子的结点结构,二叉链表
        typedef struct BiNode{
            Elemtype data;
            struct BiNode *lchile, *rchild;
        } BiNode, *BiTree;
        //包含两个孩子和双亲的结点结构,
        typedef struct TriNode{
            Elemtype data;
            struct BiNode *lchile, *rchild, *parent;
        } TriNode, *TriTree;
        ```

        - 含有n个结点的二叉树,在链式存储结构中, 共有n-1个空指针域

### 5.5 遍历二叉树和线索二叉树

#### 5.5.1 遍历二叉树

> 按某条搜索路径寻访树中的每个结点,使每个结点均被访问一次,而且仅被访问一次

1. 默认先左后右
    1. DLR先根遍历: (1)访问根结点(2)先根遍历左子树(3)先根遍历右子树
    2. LDR中根遍历: (1)中根遍历左子树(2)访问根结点(3)中根遍历右子树
    3. LRD后根遍历: (1)后根遍历左子树(2)后根遍历右子树(3)访问根结点

2. 遍历二叉树的应用见图
3. 根据遍历序列确定二叉树
    - 由二叉树的先序序列和中序序列,或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树
    - 先后序判断根,中序判断左右

1. 遍历的算法实现

    1. 递归遍历

        1. 二叉树先序遍历算法

            1. 算法思路:若二叉树为空,则空操作若二叉树非空,(1)访问根结点(2)前根遍历左子树(3)前根遍历右子树

            ```C++
            Status PreOrderTreverse(BiTree T){
                if(T == NULL) return OK; 			//注意这个OK
                else{
                    visit(T);						//取值
                    PreOrderTreverse(T->lchild);
                    PreOrderTreverse(T->rchile);
                }
                return OK:
            }
            ```



        2. 二叉树中序遍历算法
    
            Status InOrderTreverse(BiTree T){
                if(T == NULL) return OK; 			//注意这个OK,表示这条路径走到头了
                else{
                    InOrderTreverse(T->lchild);
                    visit(T);
                    InOrderTreverse(T->rchile);
                }
                return OK:
    
            }
            ```
    
        3. 二叉树后序遍历算法
    
            ```C++
            Status InOrderTreverse(BiTree T){
                if(T == NULL) return OK; 			//注意这个OK
                else{
    
                    PreOrderTreverse(T->lchild);
                    PreOrderTreverse(T->rchile);
                    visit(T);
                }
                return OK:
    
            }
            ```



        4. 遍历算法的分析
    
            从递归的角度来看, 三种算法的访问路径是相同的,只是访问结点的时机不同
    
            - 第一次经过时访问就是先序遍历
            - 第二次经过时访问就是中序遍历
            - 第三次经过时访问就是后序遍历
            - 递归算法会自动调用栈来储存先前的值
    
        5. 复杂度分析:时间复杂度O(n),
    
    2. 遍历的非递归实现(栈)
    
        1. 中序遍历非递归算法
    
            1. 算法思路:(1)建立一个栈(2)根结点进栈,遍历左子树(3)根结点出栈,遍历右子树
    
            ```C++
            Status InOrderTreverse(BiTree T){
                BiTree p,q; InitStack(S);
                p = T;
                while(p || !StackEmpty(S)){
                    if(p) {Push(S,p);p = p.lchild;}
                    else {Pop(S,q); visit(q); p = q.rchild;}
                }
                return OK;
            }
            ```
    
    3. 二叉树的层次遍历
    
        > 按层次访问二叉树,
    
        1. 算法思路:使用队列.
    
            1. 将根结点入队
            2. 队不空时循环,从队列出列一个结点,访问它,
                  - 若它有左孩子,将左孩子入队
                  - 若它有右孩子,将右孩子入队
    
        2. 算法实现
    
            ```C++
            void LevelRoder(BTNode* b){
                BTNode* p; SqQueue Q;
                InitQueue(Q);
                EnQueue(Q,b);
                while(!QueueEmppty(Q)){
                    p = DeQueue(Q);
                    visit(p);
                    if(p->lchild) EnQueue(Q,p->lchild);
                    if(p->rchild) EnQueue(Q,p->rchild);
                }
            }
            ```
    
    4. 建立二叉树的建立
    
        1. 先序遍历建立二叉树
    
            > 单一的先序序列并不能建立一个唯一的二叉树,需要加上部分空字符(‘#’),例如:ABC##SDE###G##F###
    
            ```C++
            Status CreateBiTree(BiTree &T){
                cin >> ch;
                if(ch == '#') T=NULL;
                else{
                    T=new BiNode;
                    T->data = ch;
                    CreateBiTree(T->lchild);
                    CreateBiTree(T->rchild);
                }
                return OK;
            }
            ```
    
    5. 二叉树的复制
    
        1. 算法思路:如果是空树,递归结束,否则申请新的结点空间,复制根结点,递归复制左子树,递归复制右子树
    
        2. 算法实现
    
            ```C++
            Status Copy(BiTree T, BiTree &CT){
                if(T==NULL) {CT = NULL;return 0}
                else{
            		CT = new BiTNode;CT->data = T->data;
                    Copy(T->lchild,CT->lchild);
                    Copy(T->rchild, CT->rchild);
                }
            }
            ```
    
    6. 计算二叉树的深度
    
        1. 算法思路:如果是空树,则深度为0,否则,递归计算左子树的深度记为m,递归计算右子树的深度记为n,二叉树的深度则为m与n较大者加1
    
        2. 算法实现
    
            ```C++
            int Depth(BiTree T){
                if(T == NULL) return 0;
                else{
                    m = Depth(T->lchild);
                    n = Depth(T->rchild);
                    if(m>n) return (m+1);
                    else return (n+1);
    
                }
            }
            ```
    
    7. 计算二叉树的结点数
    
        1. 算法思路:如果是空树,则结点数为0,否则结点的个数为左子树的结点个数加上右子树的结点个数
    
        2. 算法实现
    
            ```C++
            int NodeCount(BiTree T){
                if(T == NULL)
                    return 0;
                else
                    return NodeCount(T->lchild)+NodeCount(T->rchild)+1; //一个结点就加1
            }
            ```
    
    8. 计算二叉树上叶子结点的个数
    
        1. 算法思路:如果是空树则叶子结点个数为0,否则为左叶子结点个数加上右叶子结点个数
    
        2. 算法实现
    
            ```C++
            int LeafCount(BiTree T){
                if(T==NULL) return 0;
                if(T->lchild == NULL && T->rchild == NULL) return 1;
                else return LeafCount(T->lchild)+LeafCount(T->rchild);
            }
            ```



#### 5.5.2 线索二叉树

> 如何寻找特定遍历序列中二叉树结点的前驱和后继结点

1. 利用二叉链表中的空指针域,如果某个结点的左孩子为空则将空的左孩子指针域改为**指向其前驱,** 如果某结点的右孩子为空,则将空的右孩子指针域改为**指向其后继**, 这种改变指向的指针称为**线索**,加了线索的二叉树称为**线索二叉树**

    - 加两个**tag**位表示结点的两个指针域存储的是左右孩子还是前驱后继,此时结点结构如下

        \|Lchild\|Ltag\|data\|Rtag\|Rchild\|

        其中Ltag为0表示Lchild存储的是结点的左孩子,Ltag为1表示存储的是结点的前驱,右边同理

    - 注意这里的前驱后继是指前中后序遍历得到的序列的前后关系

    - 一个序列的第一个结点左孩子为空但没有前驱,最后一个结点的右孩子为空但没有后继, 把这两个指针域继续利用起来, 增加一个**头结点**, 头结点的Ltag=0,Lchild指向根结点；头结点的Rtag=1,Rchild指向遍历序列的最后一个结点.遍历序列的第一个结点的Lchild和最后一个结点的Rchild都指向头结点

#### 5.6 树和森林

> 定义:m(m>=0)棵互不相交的树的集合

##### 5.6.1树的存储结构

1. 双亲表示法:

    - 算法思路:定义数组结构,存放树的结点,每个结点包含两个域, 根结点的双亲域存放-1
        - **数据域:** 存放结点本身的信息
        - **双亲域:** 存放本结点的双亲在数组中的位置

    - 需要额外存储根结点的位置和结点总数

    - 算法实现

        ```C++
        #define MaxSize 100
        tyedef struct PTNode{
            Elemtype data;
            int parent;
        }PTNode;
        
        typedef struct {
            PTNoded nodes[MaxSize];
            int r,n;
        }PTree;
        ```

2. 孩子链表

    1. 算法思路:把每个结点孩子排列起来,看成是一个线性表,用单链表存放,则n个结点有n个孩子链表(终端结点的孩子链表为空表),而n个头指针又组成一个线性表,用顺序表存储

    2. 算法实现:

        ```C++
        typedef struct CTNode{
            int child;
            struct CTNode *next;
        } *ChildPtr;
        typedef struct{
            Elemtype data;
            ChildPtr firstchild;
        }CTBox;
        typedef struct{
            CTBox nodes[MaxSize];
            int r,n;
        }CTree;
        ```

3. 双亲表示法加上孩子链表,既可以方便找到双亲, 也可以找到孩子

    1. 算法思路:孩子链表的数组元素中加上一个域存放双亲位置

4. 孩子兄弟表示法(二叉树表示法, 二叉链表表示法)

    1. 算法思路:用二叉链表作为树的存储结构,链表中的每个结点的两个指针域分别指向第一个孩子和下一个兄弟结点(左孩子右兄弟)

    2. 算法实现

        ```C++
        typedef struct CSNode{
            Elemtype data;
            struct CTNode *firstchild, *nextsibling;
        }CSNode;
        ```



 ##### 5.6.2 树和二叉树的转换

> 关键点:树的二叉链表表示法,
>
> 把树的二叉链表表示法中右指针域存放兄弟结点,作为二叉树的右孩子

1. 算法思路:把一个树用二叉链表表示法存储, 解释为二叉树形式；反之,二叉树为存储为二叉链表,然后用树的二叉链表表示法解释,就变成了树,
2. 树变二叉树简单来说就是把兄弟变成右孩子:**兄弟相连留长子**
    1. 在兄弟之间加条线,
    2. 对于每个结点除了其左孩子,去掉与其余孩子的连线
3. 将二叉树转换成树: 左孩右右连双亲,去掉原来右孩线
    1. 加线:若p是双亲结点的左孩子,则将p的右孩子,右孩子的右孩子..., 沿分支找到所有右孩子,都与p的双亲用线连起来
    2. 抹线:抹掉原二叉树中双亲与右孩子之间的连线
    3. 调整:将结点按层次排列



##### 5.6.3 森林和二叉树的转换

1. 森林转换成二叉树
    1. 将每一棵树分别转换成二叉树
    2. 将每一棵树的根结点用线相连
    3. 以第一颗树的根结点作为二叉树的根,顺时针旋转构成二叉树结构
2. 二叉树转换成森林
    1. 抹线:将二叉树中根结点与其右孩子的连线,及沿右分支搜索到的所有右孩子之间的连线全部抹掉,使其变成孤立的二叉树
    2. 还原:将孤立的二叉树还原成树

##### 5.6.4 树和森林的遍历

###### 5.6.4.1 树的遍历

1. 先根遍历: 若树不空,则先访问根结点,然后依次遍历各子树
2. 后根遍历: 若树不空, 则先遍历各子树, 然后访问根结点
3. 层次遍历:  若树不空,, 则自上到下,自左到右访问树中结点

###### 5.6.4.2 森林的遍历

1. 算法思路:将森林看成三个部分,(1)森林中第一颗树的根结点(2)森林中第一颗树的子树森林(3)森林中其他树构成的森林

2. 先序遍历

    1. 访问森林中的第一颗树的根结点
    2. 先序遍历森林中第一颗树的子树森林
    3. 先序遍历森林中其他树构成的森林
    4. 总结:森林的先序遍历就是对森林中每个树进行先序遍历

3. 中序遍历

    1. 中序遍历森林中的第一棵树的子树森林
    2. 访问森林中第一颗树的根结点
    3. 中序遍历森林中其余树构成的森林

4. 后根遍历

    你懂的

#### 5.7 哈夫曼树

> 最优树,是指带权路径长度(WPL)最短的树
>
> 哈夫曼树:最优二叉树,构造最优二叉树的算法叫哈夫曼算法
>
> 注意:”带权路径长度最短” 是在度相同的树中比较而得的结论,因此有最优二叉树,最优三叉树等

##### 5.7.1 基本概念

- 路径:从树的一个结点到另一个结点之间的**分支**(结点之间的连线就是一个分支)构成的这两个结点之间的路径
- **结点的路径长度**:两结点间路径上的**分支數**
- **树的路径长度之和**: 从树根到每一个结点的路径长度之和, 记作TL
    - 结点数目想同的二叉树中, 完全二叉树是路径最短的二叉树(充分不必要)
- **权**: 将树中结点赋给一个有着某种含义的数值, 则这个数值称为该结点的权(被访问的概率)
- **结点的带权路径长度**: 从根结点到该结点之间的路径长度与该结点的权的乘积
- **树的带权路径长度:** 树中所有叶子结点的带权路径长度之和
- **最优二叉树:** 带权路径长度最短的二叉树


##### 5.7.2 哈夫曼算法

> 哈夫曼树中权越大的叶子离根越近

**贪心算法:** 构造哈夫曼树时首先选择权值小的叶子结点

1. 根据n个给定的权值$$\{w_1, w_2,..., w_n\}$$ 构造n棵二叉树的森林,$$F=\{T_1, T_2, T_3, ... T_n\}$$ , 其中$$T_i$$只是一个带权为$$W_i$$的根结点.
2. 在F中选取两棵根结点的权值最小的树作为左右子树,构造一棵新的二叉树,且设置二叉树的根结点的权值为左右子树权值之和.(加一个双亲结点,其权值为左右子树之和)
3. 在F中删除这两棵树,同时将新得到的二叉树加入森林当中.
4. 重复上面(2), (3),直到森林中只有一棵树为止, 这棵树就是哈夫曼树
5. 总结:(1)包含n个叶子结点的哈夫曼树共有2n-1个结点,(2)哈夫曼树的结点的度为0或2,没有度数为1的结点,(3)包含n棵树的森林要经过n-1次合并才能形成哈夫曼树,共产生n-1个新结点

**算法实现:**

```C++
typedef struct{
    int  weight;
    int parent,lch,rch;
}HTNode,*HuffmanTree;
```

1. 初始化HT [1....2n-1]:lch = rch = parent = 0;
2. 输入初始叶子结点:置HT[1....n]的weight值
3. 进行以下n-1次合并,依次产生n-1个结点HT[i], i=n+1 .... 2n-1
    1. 在HT[1...i-1]中选两个从未被选过(从parent=0的结点中选)的weight值最小的两个结点HT[s1]和HT[s2],s1,s2为两个最小结点下标
    2. 修改HT[s1]和HT[s2]的parent值:HT[s1].parent = i; HT[s2].parent = i
    3. 修改新产生的HT[i]:
        - HT[i].weight = HT[s1].weight+HT[s2].weight
        - HT[i].lch=s1;HT[i].rch=s2;

```C++
//初始化哈夫曼树
void CreateHuffmanTree(HuffmanTree HT,int n){
    if(n<=1)return;
    m = 2*n-1;				//数组共2n-1个元素
    HT = new HTNode[m+1];	//0号单元未使用,HT[m]表示根结点
    for(i = 1;i<=m;i++){	//将2n-1个元素的weight, lch, rch置为0
        HT[i].weight = 0; HT[i].lch=0;HT[i].rch=0;
    }
    for(i=1;i<=n;i++) cin >> HT[i].weight;	//输入前n个元素的权值
}
```

```C++
//合并产生n-1个结点, 构建哈夫曼树
for(i=n+1;i<=m;i++){
     Select(HT,i-1,s1,s2);	//在1-n中选择双亲域为0,且权值最小的结点,并返回他们在HT中的序号s1, s2
     HT[s1].parent = i; HT[s2].parent = i;	//表示从F中删除s1, s2
     HT[i].lch=s1; HT[i].rch = s2;			//s1, s2 分别作为i的左右孩子
     HT[i].weight = HT[s1].weight+HT[s2].weight //i的权值为左右孩子权值之和
 }
```

###### 5.7.3 哈夫曼编码

> 若将编码设计成长度不等的二进制编码, 即让待传输字符中出现次数较多的字符采用尽可能短的编码,则转换成二进制字符串便可减少
>
> 长短不等会造成重码, 如果要设计长短不等的编码,则必须是任意字符的编码都不是另一个字符的编码的前缀, 这种编码称为前缀编码
>
> 电文长度最短的前缀码称为哈夫曼编码,
>
> 哈夫曼树不唯一,哈夫曼编码也不唯一

1. 统计字符集中每个字符在电文中出现的平均概率(概率越大,要求编码越短)
2. 利用哈夫曼树的特点,权越大的叶子离根越近,将每个字符的概率值作为权值, 构造哈夫曼树.则概率越大的结点路径越短
3. 在哈夫曼树的每个分支上标上0或1:结点的左分支标0, 右分支标1, 把从根到每个叶子的路径标号连接起来,作为该叶子代表的字符的编码

**为什么哈夫曼编码能够保证是前缀编码,且总长最短?**

- 所有的字符都储存在哈夫曼树的叶子结点中, 从根到每个叶子结点的路径是唯一的,所以每个字符的编码也是唯一的,同时哈夫曼树也是带权路径长度最短的树,所以编码的总长最短

##### 5.7.4 哈夫曼编码的算法实现

> 从叶子到根逆向求每个字符的哈夫曼编码

1. 算法思路:用for循环,次数为n,依次求每个叶子结点的编码,,从叶子到根逆向求,编码字符逆序存储在一个大小为n-1的字符数组中, 结束条件为双亲结点为0,最后整理复制编码到一个编码数组中
2. 代码实现

```C++
typedef char** HuffmanCode;
char* cd;
cd[n-1] = '\0';
void CreatHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n){
    HC = new char* [n+1]; 	 //存储n个字符编码的指针数组
    cd = new char[n];	//存放临时编码的动态数组空间
    cd[n-1] = '\0';		//编码结束符
    for(int i = 1; i<=n;i++){	//逐个字符求哈夫曼编码
        start = n-1;c=i;f=HT[i].parent;
        while(f!=0){	//从叶子结点向上回溯,直到根结点
            if(HT[f].lch == c) cd[--start]='0';
            else cd[--start]='1';	//结点c是f的左孩子则生成代码0,否则生成代码1
          	c=f;f=HT[f].parent;	//继续向上回溯
        } 	//求得第i个字符的编码
        HC[i] = new char[n-start];	//为第i字符的编码分配空间
        strcpy(HC[i],&cd[start]);	//将求得的编码从临时空间cd复制到HC的当前行中
    }
    delete[] cd;	//释放临时空间
}//CreatHuffmanCode
//用栈试试?
```

##### 5.7.5文件的编码和解码

1. 编码
    1. 输入各字符及其权值
    2. 构造哈夫曼树--HT[i]
    3. 进行哈夫曼编码--HC[i]
    4. 查HC[i], 得到各个字符的哈夫曼编码
2. 解码
    1. 构造哈夫曼树
    2. 依次读入二进制码
    3. 读入0则走向左孩子；读入1则走向右孩子
    4. 一旦到达某叶子时, 即可译出字符
    5. 然后再从根出发继续译码



## 6. 图

### 6.1 图的定义和术语

1. ==图==: G=(V,E) 	// Graph = (Vertex, Edge)

    - V:顶点(数据元素)的有穷非空集合
    - E:边的有穷集合

2. **无向图**:每条**边**都是没有方向的$$(v_i,v_j)$$；相反的则是**有向图**,每条**弧**都有方向$$<v_i,v_j>$$

3. **完全图**: 图中任意两点都有边相连

    无向完全图中n个顶点有n(n-1)/2条边；有向完全图中n个顶点有n(n01)条边

4.  **稀疏图:** 有很少边的图(e<nlogn)；相反的是**稠密图**

5. **网:** 边/弧带权的图, 边/弧具有相关的数称为权, 表明从一个顶点到另一个顶点的距离或者耗费

6. **邻接:** 有边/弧相连的两个顶点

    存在$$(v_i,v_j), 则称v_i和v_j互为邻接点$；存在<v_i,v_j>, 则称v_i邻接到v_j, v_j邻接于v_i$$

7. **关联(依附):** 边/弧与顶点之间的关系

8. **顶点的度**: 与该顶点相关联的边的数目,记为TD(v)

    **有向图**中顶点的度分为入度和出度

9. **路径:** 接续的边构成的顶点序列

10. **路径长度:** 路径上边/弧的数目/权值之和

11.  **回路(环)**: 第一个顶点和最后一个顶点相同的路径

12. **简单路径**: 除了路径起点和终点可以相同,其他顶点均不相同的路径

13. **简单回路(简单环)**: 除了路径起点和终点可以相同, 其他顶点均不相同的路径

14. **连通图**: 在图G中, 若对任意两个顶点v,u都存在从v到u的路径,则成G是连通图

15. **子图:** 存在G1=(V1,E1),如果V1属于V,E1属于E, 则成G1是G的子图

16. **连通分量::** 无向图G的**极大连通子图**称为G的**连通分量**

    - **极大连通子图** ,该子图是G的连通子图,将G的任何不再此子图中的顶点加入,该子图不再连通
    - 注意:单顶点没有边的子图也是连通分量
    - 连通图的极大连通分量是他自身

17. **强连通分量**: 有向图G中的极大强连通子图

18. **极小连通子图:** 该子图是G的连通子图,删除该子图中任何一条边,子图不再连通

19. **生成树:** 包含无向图G中所有顶点的极小连通子图

20. **生成森林:** 对于非连通图, 由各个连通分量组成的生成树的集合

### 6.2 图的存储结构

#### 6.2.1 图的抽象数据类型

1. CreatGrapg(): 生成一个没有顶点的图
2. GetVex(G,v): 求图中顶点v的值
3. DFSTraverse(G):对图进行深度优先遍历
4. BFSTtaverse(G): 对图进行广度优先遍历

#### 6.2.2 数组表示法(邻接矩阵)

> 图的逻辑结构是多对多, 所以图是没有顺序存储结构的,但可以借助二维数组来表示元素之间的关系

##### 6.2.2.1 逻辑结构

- 建立一个顶点表(记录个各顶点信息)和一个邻接矩阵(表示各顶点之间的关系)
    - 顶点表Vexs[n];
    - 图的邻接矩阵是一个二维数组A.arcs[n]\[n], 大小是一个n*n的方阵, 定义为两个点之间有没有弧/边,有设为1,没有设为0
    - $$A[i][j]= \begin{cases}1, 若(v_i,v_j)之间相连 \\ 0,反之 \end{cases} $$

- 无向图的邻接矩阵的性质
    - 邻接矩阵的对角线上都是0
    - 无向图的邻接矩阵沿对角线对称
    - 无向图中某一顶点的度是这个顶点行/列中1的个数
    - 完全图的邻接矩阵中对角元素为0,其他为1
- 有向图的邻接矩阵的性质
    -  将行发出列接收视为1
    - 第i行的含义:以结点v_i为尾的弧(即出度边)；第i列的含义:以结点v_i为头的弧(入度边)
    - 顶点的出度=第i行元素之和；顶点的入度=第i列元素之和
- 网(有权图)的邻接矩阵性质
    - $$A[i][j]= \begin{cases}w_{ij}, 若(v_i,v_j)或<v_i,v_j>\in VR \\ \infty,反之 \end{cases} $$

##### 6.2.2.2 存储结构

1. 算法思想:无向网
    1. 输入总顶点数和总边数
    2. 以此输入顶点的信息存入顶点表中
    3. 初始化邻接矩阵,使每个权值初始化为极大值
    4. 构造邻接矩阵
    5. 无向图中w均为0,构造邻接矩阵是,w为1
    6. 有向网中仅为G.arcs[i]\[j]赋值, 不需要对称赋值

2. 算法实现

```C++
//初始化
#define MaxInt 32767	//表示无穷大
#define MVNum 100	//最大顶点数
typedef char VexElemtype;	//顶点的数据类型
typedef int ArcElemtype;	//假设边的权值类型

typedef struct{
    VerElemtype vexs[MVNum]; //顶点表
    ArcElemtype arcs[MVNum,MVNum]; //邻接矩阵
    int vexnum,arcnum; //图的当前点数和边数
}AMGraph；
//建立无向网
Status CreateUDN(AMGraph &G){
    cin >> G.vexnum >> G.arcnum;	//输入总顶点数,总边数
    for(i = 0;i<G.vexnum;i++){
        cin >> vexs[i];		//输入顶点信息
    }
    for(i=0;i<G.vexnum;i++)		//初始化邻接矩阵
        for(j=0;j<G.vexnum;j++)
            G.arcs[i][j]=MaxInt;	//边的权值均为极大值
    for(k=0;k<G.arcnum;++k){
        cin >> v1>>v2>>w; //输入一条边所依附的顶点和边的权值
        i = Locate(G,v1);	//在顶点表中查找v1的位置
        j = Loacte(G,v2);	//确定v1,v2在G中的位置
        G.arcs[i][j] = w;	//边(v1,v2)的权值置为w
        G.arcs[j][i] = G.arcs[i][j];	//无向图对称
    }
    return OK;
}//CreateUDN
```

3. 邻接矩阵的优缺点
    1. 便于查找顶点,不利于增加和删除顶点,在稀疏图中浪费空间

#### 6.2.3 链式存储结构

> 邻接表, 邻接多重表, 十字链表

##### 6.2.3.1邻接表

- **邻接表的概念**
    - 在邻接表中对每个顶点建立一个单链表,第i个单链表中的结点表示依附于顶点$$v_i$$的边, 每个结点由三个域组成,邻接点域(adjvex)指示与顶点$$v_i$$邻接的点在图中的位置(数组下标), 链域(nexarc)指示下一个边/弧的结点,数据域存放权值,每个链表附一个表头结点,表头结点有两个域,一个链域指向链表的第一个结点,数据域存放顶点信息,
    - 表头结点单独建表
    - 各个边结点链入顺序是任意的,所以邻接表不唯一
    - 若无向图中有n个顶点, e条边. 则其邻接表需要n个表头结点和2e个表结点,适宜存储稀疏图
    - 无向图中第i个顶点的度表示为第i个单链表中表结点的个数
    - 有向图中单链表中结点存储顶点的出度,如果要统计入度需要遍历整个邻接表, 此时可以建立有向图的逆邻接表存储顶点的入度
    - 有向图中如果有n个顶点, e条边,则需要存储n个表头结点和e个表结点

- **邻接表的建立**
    - 算法思路
        1. 输入总顶点数和总边数
        2. 建立顶点表:输入顶点数据,初始化表头结点的指针域为空
        3. 创建邻接表:依次输入每条边依附的两个顶点,确定两个顶点的序号i和j,建立边结点；将此边结点分别插入到$$v_i, v_j$$对应的两个边链表的头部(头插法)
    - 算法实现见github
- 邻接表的特点:
    - 在邻接表上容易找到任一顶点的第一个邻接点和下一个邻接点,但是要判断任一两个顶点之间是否有边就需要搜索这两个顶点的单链表,因此不及邻接矩阵方便
    - 节约稀疏图的时间,需要n个表头指针和2e个表结点
    - 邻接矩阵和邻接表的联系(无向网):邻接表中每个单链表对应邻接矩阵中的一行,链表中的结点个数等于一行中的非零元素的个数；邻接矩阵是唯一的但邻接表不是
    - 邻接矩阵的空间复杂度为O(n^2),邻接表的空间复杂度为O(n+e)
    - 邻接矩阵用于稠密图,邻接表用于稀疏图

##### 6.2.3.2 十字链表

> 十字链表是有向图的另一种链式存储结构, 可以看成是将有向图的邻接表和逆邻接表结合起来得到的链表
>
> 十字链表的弧结点有两个被指两个指向,弧头和弧尾都要指向弧结点,不过一个是作为出度,一个是作为入度,弧结点的两个指向:一个指向弧头相同的下一个弧结点；一个指向弧尾相同的下一个弧结点

1. 算法思路
    1. 顶点结点三个域:一个存储数据的数据域,一个存储出度边单链表的链域, 一个存储入度边单链表的链域
    2. 弧结点五个域:第一个存放弧头位置的头域,第二个存放弧尾位置的尾域,第三个存放弧头相同的下一条弧(入度边单链表要用),第四个存放弧尾相同的下一条弧(出度边单链表会用到),第五个域存放权值相关信息；
2. 算法实现github

##### 6.2.3.3 邻接多重表

> 无向图的另一种链式存储结构, 邻接表中同一条边的结点要存储两次,不方便, 邻接多重表每条边的结点只存储一次
>
> 邻接表中容易求得顶点和边的信息,缺点是操作不方便,在邻接表中任何一条边都会出现两次

**有点迷**

### 6.3 图的遍历

> 遍历图中所有顶点,每个顶点仅被访问一次,称为图的遍历
>
> 遍历的实质:找到每个顶点的邻接点的过程
>
> 避免重复访问:设置辅助数组visited[n]用来标记每个被访问的结点,初始状态visited[i]=0,顶点i被访问设置visited[i]=1, 防止被多次访问

#### 6.3.1深度优先遍历(Depth_Firest Search-DFS)

1. 算法思路:
    1. 在访问图中某一起始顶点V后, 由v出发,访问他的任意邻近顶点$$w_1$$
    2. 再从$$w_1$$出发,访问与$$w_1$$邻接但是还未被访问的顶点$$w_2$$
    3. 再从$$w_2$$出发,进行类似的访问
    4. 如此, 直至到达所有的邻近顶点都被访问过的顶点u为止
    5. 接着向后退一步,退回前一个刚访问过的顶点,看看是否还有其他没有被访问过的邻接顶点:如果有就此顶点出发进行上述操作；如果没有再退一步,重复上述过程

2. 算法实现

    > 利用邻接矩阵研究深度优先搜索

    ```C++
    #include"MG_CreateUDN.cpp"
    #define Max 20
    bool Visited[Max];
    void DFS(AMGraph &G, int v){
        cout << v; Visited[v] = 1;
        for (int  w = 0; w < G.vexnum; w++)
            if (G.arcs[v][w] != 0 && !Visited[w])
                DFS(G,w);
        
    }
    ```



#### 6.3.2 广度优先遍历(Breadth_First Search-BFS)

1. 算法思路:从图的某一结点出发,首先依次访问该结点的所有邻接点,再按这些顶点被访问的先后次序,依次访问,每个顶点的未被访问的邻接点,重复上述过程,直至所有的邻接点都被访问为止,类似二叉树的层次遍历

2. 算法实现

    ```C++
    void BFS(Graph G, int v){
        cout << v;visited[v] = true;
        InitQueue(Q);
        EnQUeue(Q,v);
        while(!QueueEmpty(Q)){
            DeQueue(G,u);
            for(w=FirstAdjVex(G,u);w>=0;w=NextAdjVex(G,w))
                if(!visited[w]){
                    cout << w;visited[w] = true; EnQueue(G,w);
                }
        }
    }
    ```

    

### 6.4 图的应用

#### 6.4.1 最小生成树

1. **生成树**: 所有的顶点均由边连接在一起,但不存在回路的图,一个图可以有不同的生成树, 生成树的顶点和图的顶点数目相同；生成树是图的极小连通子图,去掉一条边则非连通；一个有n个顶点的连通图的生成树有n-1条边；在生成树中加上一条边必然生成回路；生成树中任意两个顶点间的路径是唯一的

2. **无向图的生成树:** 深度优先遍历生成树；广度优先遍历生成树

    设图G=(V.E)是一个连通图,当从图的任意顶点出发遍历图G时,将边集E(G)分成两个集合T(G)和B(G),其中T(G)是遍历图时所经过的边的集合,B(G)是未经过的边的集合.显然,G1(V,T)是图G的极小连通子图,即子图G1是连通图G的生成树

3. **最小生成树:** 给定一个无向网,在该网的所有生成树中,使得各边权值之和最小的那棵生成树就是该网的最小生成树,也叫最小代价生成树

4. **构造最小生成树(Minimum Spanning Tree)**: MST性质:设N=(V,E)是一个连通网,U是顶点集V的一个非空子集,其中u$$\in U,v\in V-U$$,若边(u,v)是一条具有最小权值的边,则必存在一棵包含边(u,v)的最小生成树

    - **解释:** 在生成树的构造过程中,图中n个顶点分属两个集合:已经落在生成树上的顶点集U；尚未落在生成树上的顶点集V-U

        接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边

    

#### 6.4.1.2 普里姆(Prime)算法

1. 算法思想:算法思路：从U集合出发，每次从V-U集合中，找到一条权重最小的边的顶点相连；因此U集合不断扩大，V-U集合不断缩小到空集合，最后最小生成树生成。
    1. 设N=(V,E)是连通网,TE是N上的最小生成树中边的集合
    2. 初始$$令U={u_0},(U_0 \in V),TE=\{\}$$
    3. $$在所有的u \in U, v \in V-U的边(u,v) \in E 中,找一条最小代价的边(u_0,v_0)$$
    4. $$将(u_0,v_0)并入集合TE, 同时v_0并入U$$
    5. 重复上述操作直至U=V为止, 则T=(V,TE)为N的最小生成树

#### 6.4.1.2 克鲁斯卡尔(Kruskal)算法

1. 算法思想
    1. 设连通网N=(V,E),另最小生成树初始状态为只有n个顶点而无边的非连通图T=(V,{}), 每个顶点自成一个连通分量
    2. 在E中选取代价最小的边, 若该边依附的顶点落在不同的连通分量上(即:不能形成环),则将此边加入T中,否则舍去此边,选取下一条代价最小的边
    3. 以此类推,直至T中所有顶点都在同一连通分量上
    4. 最小生成树可能不唯一

#### 6.4.1.3 普里姆算法和克鲁斯卡尔算法的区别

1. 普里姆算法: 算法思想:选择点；时间复杂度:O($$n^2)$$(n为顶点数)；适应范围稠密树
2. 克鲁斯卡尔算法: 算法思想:选择边；时间复杂度$$O(e \log_2e)$$ (e为边数)  ；适应范围:稀疏树

### 6.4.2 最短路径

> 问题抽象:在有向网中A点(起点)到达B点(终点)的多条路径中,寻找各边权值之和最小的路径,即最短路径. 最短路径不一定包含所有顶点

1. 第一类问题:两点之间最短路径; 单源最短路径-用Dijkstra(迪杰斯特拉)算法
2. 第二类问题:某源点到其他各点最短路径；多源最短路径-用Floyd(弗洛伊德)算法
#### 迪杰斯特拉(Dijkstra)算法
> 从一个顶点到其余各顶点的最短路径算法,解决的是有权图中的最短路径问题
> 迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
1. 算法思路
   1. $$首先指定源点v_0, 然后引入一个辅助变量D,他的每一个分量D[i]表示从源点到每一个终点v_i的最短路径长度,.他的初态为:如果从源点v_0到终点v_i有弧,则D[i]上的值为权值,否则置D[i]为\infty $$
   2. 引入集合S, S包含以求出最短路径的点(初始化为S(v_0),则V-S为未求出最短路径的点(也包含v_0到该集合的所有路径)
   3. 从集合V-S中找到与集合S的最短路径的点u, 加入S集合
   4. 更新V-S集合的路径(如果通过新的路径可以让距离变得更短,就更新集合V-S的信息,if((v_0,u)+(u,v_k) < (v_0,v_k)) 则更新U)
   5. 循环执行3,4 直到遍历V-S为空,得到v_0到其他顶点的最短路径
2. 算法实现

#### 弗洛伊德(Floyd)算法
> 解决任意两点间的最短路径的算法

1. 算法思想原理
    从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。
2. 算法描述
   1. 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。
   2. 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。
3. 算法步骤
   1. 初始时设置一个n阶方阵, 令其对角线元素为0,若存在弧(v_i,v_j)则对应元素为权值,否则为无穷大
   2. 逐步试着在原直接路径中增加中间顶点,若加入中间顶点后路径变短,则修改之,否则维持原值,所有结点试探完毕,算法结束


### 6.4.3拓扑排序和关键路径
- **有向无环图**: 无环的有向图(DAG图, Directed Acyclic Graph)
- **AOV网**:用一个有向图表示一个工程的各子系统及其相互制约的关系,其中以顶点表示活动,弧表示活动之间的制约关系,称这种图为顶点表示活动的网, 简称**AOV网**(Activity On Vertex network),AOV网中不允许有回路
- **AOE网**: 用一个有向图表示一个工程的各子系统及其相互制约的关系, 以弧表示活动,弧上的权表示活动持续的时间, 以顶点表示活动的开始或结束,称这种有向图为表示活动的网,简称**AOE网**(Activity On Edge network) , AOE网中只有一个入度为0的点,称为源点,只有一个出度为0的点, 称为汇点
  - 用AOV网解决拓扑排序问题；用AOE网解决关键路径问题
#### 6.4.3.1 拓扑排序
在AOV网中没有回路的前提下,将所有的活动排成一个线性序列,使得若AOV网中有弧<i, j>存在,则在这个序列中i一定排在j的前面,具有这种性质的线性序列称为*拓扑有序序列*,相应的拓扑有序排序的算法成为**拓扑排序**
   <!--类似广度优先遍历BFS-->

   1. 算法步骤
      1. 在有向图中选择一个没有入度的顶点输出
      2. 从图中删除该顶点和以他为尾的弧
      3. 重复1, 2,直至所有的顶点都被输出
   2. 检测AOV网中是否存在环方法: 如果对有向图构造拓扑有序序列,网中所有的顶点都在它的拓扑有序序列中,则AOV网中必不存在环

#### 6.4.3.2 关键路径
  > 对AOE网的研究问题是:完成整项工程至少需要多少时间；哪些活动是**影响工程进度的关键**
  > 由于AOE网中某些活动可以并行的进行,所以完成工程的最短时间是从开始点到完成点的最长路径的长度(权值之和), 路径长度最长的路径叫做**关键路径**
1. 关键路径的四个描述量
   1. ve(vj)--表示事件vj的最早开始时间
   
   2. vl(vj)--表示事件vj的最迟开始时间
   
      上一个事件的最早开始时间加上上一个活动的持续时间就是这个事件的最早开始时间
   
   3.  e(ai)--表示活动ai的最早开始时间
   
   4. l(ai)--表示活动ai的最迟开始时间
   
      e(ai) = ve(j)
   
      l(ai) = vl(k) - $$w_{j,k}$$
   
   5. l(i)-e(i)--表示完成活动ai的时间余量
   
   6. **关键活动**: 关键路径上的活动, 即l(i)==e(i)的活动
   
   7. **关键路径：** 由关键活动构成的路径
   
2. 求解

   1. 事件的最早开始时间ve(j)：从ve(0)=0开始往前递推，直到事件j,找到其中最长的一条路径，就是事件的最早发生时间$$ve(j) = Max_i\{ ve(i) + dut(i,j)\}$$ 

   2. 事件的最迟开始事件vl(i): 从vl(n-1)=ve(n-1)起向后推， 直到事件i，找到其中最短的一条路径，就是事件发生的最迟时间：$$vl(i)= Min_j\{vl(j) - dut(i,j)\}$$ 

      <!--交作业截止时间 - 写作业所需时间 = 最晚开始抄作业时间-->

   <!-- 一个是离时间开始时最大，一个是离时间结束时最大 -->



## 7. 查找

> 查找和排序都是属于数据的运算
>
> 研究查找表的各种组织方法和查找过程的实施

### 7.1 基本概念

1. **查找表**：是由同一类的数据元素构成的集合，由于集合中的数据元素之间存在着松散的关系，因此查找是一种应用灵便的结构<!--查找表也是一种数据结构-->
2. **关键字：** 是数据元素中某个数据项的值，用他可以来标识一个数据元素，当数据元素只有一个数据项时，其关键字就是该数据元素的值
3. **查找：** 根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或是数据元素，如果表中存在这样一个元素，称为查找成功，返回数据信息或者位置。否则查找不成功，返回空。
4. **静态查找表：**查找前后查找表不变；相对的是**动态查找表**，查找前后查找表发生改变
5. **平均查找长度(Avreage Search Length)：**关键字的平均比较次数 $$ASL=\displaystyle \sum^{n}_{i-1} {p_i}{c_i}$$ n:查找次数；pi：查找第i个记录的概率；ci：查找第i个记录所需的比较次数

### 7.2 静态查找表

#### 7.2.1 顺序查找

==适合顺序表或者线性链表表示的静态查找表、表中元素无序==

1. 代码实现SSTable_Seq.cpp

2. 时间复杂度(n);空间复杂度(1)

3. ASL

4. **讨论：**

   1. 记录查找概率不相等时如何提高查找概率

      将访问概率高的元素存在后面，将访问概率底的存在前面

   2. 查找概率无法获得时：按照查找概率动态调整记录顺序

      1. 在每个记录前设一个访问频度域
      2. 始终保持记录按非递增有序的次序排列
      3. 每次查找后均将刚查到的记录直接移到表头

5. 将比较频度大的数据放在访问次数比较少的位置

#### 7.2.2 折半查找（二分查找）

==只适用于有序表，且为顺序存储结构==

 1.  代码实现：Search_Bin.cpp

 2.  折半查找的性能分析-判定树

 3.  如果确定了有序表,那么判定树就是唯一的

     利用判定树来分析折半查找法，其时间复杂度为$$O(log_2 n)$$,判定树是非完全二叉树。树内节点表示查找成功的情况，完全二叉树缺失的结点表示查找不成功的情况

	4. ASL

#### 7.2.3 分块查找（索引顺序表）

> 将表分成若干块，块内可以是无序的，但分块是有顺序的。为每一个块建立索引，构建索引顺序表
>
> ==分块有序，块内无序==

- 条件1：分块有序：若i<j, 则第j块中所有记录的关键字均大于第i块中的最大关键字
- 条件2：建立索引表，每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序
- 查找过程：先确定待查记录所在块（顺序或折半查找）再在块内查找（顺序查找）
- 优缺点：
  - 优点：插入和删除比较容易，无需移动大量元素
  - 缺点：要增加一个索引表的存储空间，并对初始索引表进行排序操作
  - 适用情况：如果线性表既要快速查找又经常动态变化，则可以使用分块查找
  - ASL：

### 7.3 动态查找表

> ==当表插入和删除操作比较频繁时，需要用到动态查找表==
>
> 表结构在查找过程中动态生成，对于给定的key若表中存在则成功返回；若表中不存在，则插入关键字等于key的记录

#### 7.3.1 二叉排序树

1. 定义:或为空树；或具有下列性质的树:(1)若他的左子树不为空,则左子树上所有结点的值均小于它根结点的值；(2)若它的右子树不为空,则右子树上所有结点的值均大于根节点上的值；(3)它的左右子树也分为二叉排序树
2. 在二叉排序树中序遍历可以得到一个非递减序列
3. 二叉排序树的查找代码实现:SearchBTS.cpp
4. 二叉树的插入删除代码实现: BinarySortTree.cpp
5. 二叉排序树的生成:
   1. 二叉排序树并不唯一,只要保证左边的小于中间的小于右边就行
   2. 插入的结点均为叶子结点,所以不需要移动其他结点
6. 二叉查找树的性能分析:
   1. 比较较的关键字次数= 此节点所在的层次数
   2. 最多的比较次数=树的深度
   3. ASL与树的形态有关. 以最小的结点作为根节点的二叉排序树ASL是最大的；二叉排序树与折半查找的判定树相同时,ASL是最小的  

#### 7.3.2 平衡二叉树(AVL树)

> 平衡二叉树首先是二叉排序树, 使二叉排序树形态均衡

- 具有下列性质的二叉排序树,称为平衡二叉树

  - 左子树和右子树的高度之差的绝对值小于等于1
  - 左子树和右子树也是平衡二叉树

- 平衡二叉树的每个结点额外有一个域,存放该结点左子树和右子树的高度差,这个数字称为结点的平衡因子

  - 平衡因子 = 结点左子树的高度 - 结点右子树的高度
  - 根据平衡二叉树的定义,所有结点的平衡因子只能为1,-1,0

- 失衡二叉排序树的分析与调整

  1. 分析:==当在AVL树中插入一个新结点时==,结点的平衡因子大于1, 则AVL树失衡,必须重新调整二叉树的结构,使之恢复平衡.

  2. 失衡的四种方式:LL型,LR型,RL型,RR型

     ![失衡的四种方式](/home/zyanjun/Documents/github/zyanjnn/pictures/失衡的四种类型.png)

  3. 最小失衡子树:平衡因子=2的结点

  4. 失衡的调整

     1. LL型调整:
        1. B结点带着其左子树一起上升
        2. A结点成为B的右子树
        3. 原来B结点的右子树成为A结点的左子树
        4. 课本:右旋
     2. RR型
        1. B结点带着其右子树上升
        2. A结点成为B的左子树
        3. 原来B结点的左子树成为A结点的右子树 
        4. 课本:左旋
     3. LR型
        1. C结点单独上升
        2. A结点成为C的右子树,B结点成为C的左子树
        3. 原来C结点的左子树作为B结点的右子树；原来C结点的右子树作为A结点的左子树
        4. 课本:先左后右
     4. RL型的调整
        1. C结点单独上升
        2. A结点成为C的左子树,B结点成为C的右子树
        3. 原来C结点的左子树作为A的右子树；原来C结点的右子树放在左子树上
        4. 课本:先右后左

  5. 算法思路

     1. 递归插入返回时,开始计算平衡因子,第一次出现2或-2时调整



#### 7.3.3 B树

### 7.4 哈希表

==根据设定的哈希函数$$H(key)$$和处理冲突的方法将一组关键字映射到一个有限的、连续的地址集上，并以关键字在地址集的“像”作为记录在表中的存储位置

#### 7.4.1 定义

> 位置和关键字存在确定关系,通过位置可以直接访问关键字
>
> 关键字集合到存储地址集合的映射
>
> 将任意长度的消息压缩到固定长度的的消息摘要的函数

- **散列方法**:选取某个函数,依据该函数按关键字计算元素的存储位置,并按此存放；查找时,由同一个函数对给定值k计算地址,将k与地址单元中元素关键码进行对比,确定是否查找成功
- **散列函数**:散列方法中使用的函数
- **散列表**: 按散列方法构建的表
- **冲突:** 不同的关键码映射到同一个散列地址

#### 7.4.2 散列表的构造

-  所选择的函数尽可能简单,以提高转换速度
- 所选函数对关键码计算出的地址,应该均匀的分布在散列表中,减少空间浪费
- 尽量减少冲突

##### 7.4.2.1 构造散列函数需要考虑的因素

1. 执行速度
2. 关键字长度
3. 散列表大小
4. 关键字的分布情况
5. 查找频率

##### 7.4.2.2 散列函数的构造要求

1. n个元素原来仅需要占据n个地址,虽然散列查找是以空间换时间,但仍希望散列的地址空间最小
2. 无论用什么方法存储,都要尽量均匀的存放元素,以避免冲突 

##### 7.4.2.3 散列函数的构造方法

1. 直接定值法:取关键字的线性函数值作为哈希地址$$H(key)=key 或 H(key) = a*key+b$$

   优点:线性函数不会产生冲突；缺点:空间效率低

2. 数字分析法

3. 平方取中法

4. 折叠法

5. **除留余数法**:除以一个整数(不大于哈希表表长m的数)取余数,把余数作为哈希地址$$H(key) = key \ \ MOD \ \  p\ \  ,\  p \leq m$$ (一般情况下选p为质数或不包含小于20的质因数的合数)

6. 随机数法

#### 7.4.3 解决冲突的方法

1. 开放定址法: 有冲突时就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将数据元素存入：m为散列表长度, 开放定址法都是对表长取余

   $$H_i = (Hash(key) + d_i) \ MOD \  m ( 1 \leq i < m )$$

   1. 线性探测法:从冲突的地址一次向后遍历寻找,直到找到空的散列地址,将数据存入:$$d_i$$=1,2,3,4,5...., m-1
   2. 二次探测法: $$d_i = 1^2, -1^2, 2^2, -2^2, 3^2, -3^2,.... \pm k^2 (k \leq m / 2) $$ **m必须是4k+3的质数**
   3. 伪随机探测:$$H_i = (Hash(key)+d_i) mod m (1 \leq i < m) d_i为伪随机数$$ 

2. 链地址法: 

   1. 基本思想:相同散列地址的记录链接成一单链表,m个散列地址就设m个单链表, 然后用一个数组将m个单链表的表头指针存储起来形成一个动态的结构 
   2. 链地址法建立散列表步骤
      1. 取数据元素的关键字key,求散列地址,若该地址对应的链表为空,就将该元素插入此链表,否则执行2
      2. 计算key的下一个存储地址,若该地址对应的链表不为空,则利用链表的前插法或者后插法,将该元素插入此链表(凡是哈希地址为i的记录都插入到头指针为ChainHash[i]的链表中)

3. 再散列法

4.  建立一个公共溢出区

#### 7.4.4 散列表的查找

- 给定k值,根据哈希函数确定哈希地址, 若表中此位置没有记录,则查找不成功,否则比较关键字,若和给定值相同,则查找成功,否则根据造表时设定的处理冲突的方法找“下一个地址”,直到哈希表中某个位置为空,或者表中所填记录等于给定值为止
- 散列表的查找效率分析:使用平均查找长度ASL来衡量查找算法, ASL取决于
  - 散列函数
  - 处理冲突的方法
  - 散列表中的装填因子$$ \alpha = \frac {表中填入的记录数} {哈希表的长度}$$



#### 7.4.5 结论

1. 散列表优于传统技术
2. 链地址法优于开地址法
3. 除留取余法作为散列函数优于其他函数 

## 8 排序

> 将无序序列排成一个有序序列
>
> 分类:插入排序：直接插入排序、折半插入排序、希尔排序、
>
> 交换排序：冒泡排序、快速排序
>
> 选择排序：简单选择排序、堆排序
>
> 归并排序：2-路归并排序
>
> 基数排序

### 8.1 插入排序

> 在有序序列中插入一个元素，保持序列有序，有序表的长度不断增加

1. 直接插入排序：采用顺序查找法从后向前查找插入顺序
2. 折半插入排序：当前位置之前的元素已经排好序了，可以使用折半查找查找插入顺序
3. 希尔排序：先分块，然后块间有序

### 8.2 交换排序

1. 冒泡排序:
2. 快速排序:

### 8.3 选择排序

1. 简单选择排序:从数据中选择最小的放在第一个位置，然后选择第二小的，放在第二个位，依次类推；
2. 堆排序：
   1. 堆的定义:实质是满足如下性质的完二叉树：二叉树中任一非叶子结点均小于（大于）它的孩子结点,如果根大就大根堆，如果根小就是小根堆
   1. 堆的存储结构是数组，堆的逻辑结构是二叉树
   1. 堆调整：对某个不满足堆排序的结点进行调整
     1. 输出堆顶元素后，以堆中最后一个元素代替它
     1. 然后将根节点值与左右子树的根节点值进行比较，并于其中较小（大）者进行交换
     1. 重复上述操作，直到叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为＂筛选＂
   1. 怎么由一个无序序列建立一个堆：
       1. 首先将数组存储为二叉树，然后对二叉树进行堆调整

### 8.4 归并排序

