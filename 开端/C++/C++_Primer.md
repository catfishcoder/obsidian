# 1.开始
## 1.1 一个简单的C++程序
```C++
#include<iostream>
int main(){
	std::cout << "hello world" << std::endl;
	return 0;
}
```
- `#include<iostream>`：预处理命令，在程序的预处理阶段将指定的标准库复制到当前文件中；
- 函数：包括**返回类型**，**函数名**，**形参列表**， **函数体**四部分:
	- main函数的返回类型必须为`int`，main函数的返回值被用来指示状态，0表示成功，非0的返回由系统定义;
	- 函数名建议驼峰命名法;
	- 形参的值可以在形参列表中初始化;
	- 用花括号括起来的部分称为函数体;
- 命名空间：命名空间可以避免使用不同库中相同名字导致的冲突标准库中定义的所有名字都在命名空间std中

## 1.2 输入输出
- C++本身没有定义任何输入输出，而是用标准库来提供IO机制；
- `iostream`标准库提供`istream`和`ostream`两个基础类型，表示输入流和输出流，一个流就是一个字符序列；
- 标准库定义了四个IO对象：`cin`标准输入、`cout`标准输出、`cerr`标准错误输出、`clog`日志；
- 输出运算符`<<`，将右边的运算对象写入到左边，注意左侧的运算对象必须是一个ostream对象；
- 输入运算符`>>`类似
- **缓冲区**：每个输出流都管理一个缓冲区，用来保存程序读写的数据。字符在串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。缓冲刷新的原因有很多，程序正常结束，作为main函数return操作的一部分，缓冲区被刷新；缓冲区满时刷新缓冲区，使用操作符如`endl`显式刷新缓冲区等；

## 1.3 控制语句
### 1.3.1 循环
- while循环
```C++
while(condition){            //如果为真，就执行语句
	statement(s);
}
```
- do..while循环
```C++
do{                         //先执行循环再进行判断
	statements;
}while(condition)
```
- for循环
	- for循环的控制流
		- **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
		- 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
		- 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
		- 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。
	```C++
	for( init; condition; increment){
		statement(s);
	}
	```
- 循环控制语句
	- break语句：终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。
	- continue语句：引起循环跳过主体的剩余部分，立即重新开始测试条件。
	- goto语句：将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。
### 1.3.2 判断
- if语句
```C++
if(boolean_expression){
	statement1;                    //如果条件为真就执行语句1
}else{
	statement2；                   //如果条件为假就执行语句2
}
```
- switch语句
	- switch必须遵循以下规则
		- **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
		- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
		- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
		- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
		- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
		- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 _继续_ 后续的 case，直到遇到 break 为止。
		- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。
```C++
switch(expression){
	case constant-expression : 
	statement(s);
	break;    // 可选的 
	case constant-expression : 
	statement(s); 
	break;    //可选的 
	//您可以有任意数量的 case 语句
	default : // 可选的 
	statement(s);
}
```

## 1.4 类简介
- 通过定义类来定义一个数据结构（相互之间存在一种或多种特定关系的数据元素的集合）
- 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
- 类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。
![类](https://gitee.com/zyanjun/img_service/raw/master/img/cpp_object_class.png)
- 通过使用`.`操作符来访问类的成员

## 1.5 编译运行程序
在linux中使用g++来编译C++程序，具体命令为:`g++ source.cpp`，默认生成的可执行文件名为`a.out`,使用`-o`参数指定文件名



---

title: "C++_day2"

date: 2021-12-28T12:09:53+08:00

draft: false

tags: ["C++"]

---

  

# 2. 变量和基本类型

  

## 2.1 基本内置类型

> C++本身定义了一套算数类型和空类型(void),算数类型包括字符、整型、布尔值和浮点数，空类型不对应具体的值
> 在不同的机器上算数类型的具体大小也不相同，C++只定义了最小尺寸

### 2.1.1 算数类型
  
(以下示例是在64位机上)
| 类型        | 含义           | 最小尺寸            |
| ----------- | -------------- | ------------------- |
| int         | 整形           | 32位                |
| long        | 长整形         | 64位                |
| long long   | 长长整形       | 64位                |
| short       | 短整型         | 16位                |
| char        | 字符型         | 8位                 |
| wchar_t     | 宽字符         | 32位                |
| char16_t    | Unicode字符    | 16位                |
| char32_t    | Unicode字符    | 32位                |
| float       | 单精度浮点型   | 32位，6位有效数字   |
| double      | 双精度浮点型   | 64位，10位有效数字  |
| long double | 扩展精度浮点型 | 128位，10位有效数字 |
| bool        | 布尔类型       | 8位                 |

+ 一个char类型应该保证能够表示任意字符对应的数字值
+ 在C++中，一个int至少和一个short一样大；一个long至少和一个int一样大；一个long long至少和一个long一样大

**带符号类型和无符号类型**
	+ 除了布尔类型和拓展的字符型之外，其他的整形可以划分为带符号的(signed)和无符号的(unsigned)，带符号的可以表示正数、负数和零；无符号类型仅能表示大于零的值
	+ 类型int、short、long、long long、都是带符号的，在这些类型名前添加unsigned来声明无符号数。类型unsigned int可以缩写为unsigned.
	+ 与整形不同，字符型被分为三种：char、signed char、unsigned char.这三种并不一样，但表现形式只有带符号和无符号两种。其中char的类型是哪一种由编译器决定
	+ 无符号类型的所有比特都用来储存值，例如8比特的unsigned char可以表示0-255之间的值，而8比特的signed char可以表示-128 - 128之间的值

**如何选择类型**

***对不同的数据应该选择不同的数据类型，从而简化选择的过程***
	- 如果明知其值不可能为负，则应该选择无符号类型
	- 使用int进行整数运算，short通常太短而long通常和int有一样的尺寸，如果数值超过的int的范围，则应该选择long long类型
	- 在算数表达式中不要使用char或者bool类型，因为在某些编译器中char是无符号的，在另一些编译器中是带符号的，如果需要不大的整数应该使用signed char或者unsigned char
	- 执行浮点运算时，通常使用double,因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几

**基本内置类型的机器实现**
+ 计算机以比特序列来存储数据，大多数计算机以2的整数次幂作为块来处理内存，可寻址的最小内存块称为**字节(byte)**，存储的基本单元称为**字(word)**,一个字包含几个字节，大多数计算机将每一个字节和一个数字（称为地址）关联起来，

### 2.1.2 类型转换
  
***对象的类型定义了对象能够包含的数据和能参与的运算。当程序的某处使用了某种类型而对象应该取另一种类型时程序会自动进行类型转换，具体过程如下***
	+ 当把一个非布尔类型的算数值赋给布尔类型时，任何非零的数都为真，零为假;
	+ 当把一个浮点数赋给一个整数时，小数点之后的位将被舍弃;
	+ 当给一个无符号类型的数一个超出其表示范围的值时，结果是初始值对无符号类型表示数值总数取模之后的余数
	+ 当给一个带符号类型的数一个超出其表示范围的值时，结果是未定义的;

**总结：避免无法预知和依赖实现环境的行为**

### 2.1.3 字面值常量

***形如 42 的值被称为字面值常量(literal)，叫字面值是因为只能用值来称呼它，常量表示其不能被修改。每种字面值常量都表示一种数据类型***

1. **整形和浮点型字面值：**
	1. 十进制字面值的类型是int、long、long long中能容纳其数值的尺寸最小者；八进制和十六进制字面值的类型是int, unsigned int, long, unsigned long, long long, unsigned long long中能容纳其数值的尺寸最小者，类型short没有对应的字面值
	2. 尽管十进制字面值可以存储在带符号数据类型中，但是严格来说十进制字面值不会是负数，如果使用了一个形如 -42 的负十进制字面值，那么负号并不在字面值之内，其作用仅是对字面值取反而已
	3. 浮点型字面值表示为一个小数或以科学计数法表示的指数
2. **字符和字符串字面值**
	1. 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符称为字符串字面值
	2. 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾添加一个空字符('\0'),因此字符串字面值的实际大小比其内容大1
3. **布尔字面值和指针字面值**
	true和false是布尔类型的字面值；nullptr是指针类型的字面值

4. **转义序列**
1. 有两类字符并不能直接使用，一类是**不可打印字符(nonprintable)**，一类是在C++语言中有特殊含义的字符。在这种情况下需要用到**转译序列(escape sequence)** 来表示，转译序列以反斜杠作为开始
| 符号       | 转译序列 |
| ---------- |:--------:|
| 换行符     |   `\n`   |
| 横向制表符 |   `\t`   |
| 响铃       |   `\a`   |
| 纵向制表符 |   `\v`   |
| 退格符     |   `\b`   |
| 双引号     |   `\"`   |
| 单引号     |   `\'`   |
| 反斜线     |   `\\`   |
| 问号       |   `\?`   |
| 回车符     |   `\r`   |
| 进纸符     |   `\f`   |

5. **指定字面值的类型**
1. 字符和字符串字面值

| 前缀 | 含义                          | 类型     |
| ---- | ----------------------------- | -------- |
| u    | Unicode16字符                 | char16_t |
| U    | Unicode32字符                 | char32_t |
| L    | 宽字符                        | wchar_t  |
| u8   | UTF-8(仅用于字符串字面值常量) | char     |

2. 整型字面值

| 后缀     | 最小匹配类型 |
| -------- | ------------ |
| u或者U   | unsigned     |
| l或者L   | long         |
| ll或者LL | long long    |


3. 浮点型字面值

| 后缀   | 最小匹配类型 |
| ------ | ------------ |
| f或者F | float        |
| l或者L | long double  |

## 2.2 变量

***变量提供一个具名的、可供程序操作的存储空间，对C++程序员来说，“变量(variable)和对象(object)一般而言是相等的***

### 2.2.1 变量定义
`类型说明符 变量名 [= 初始值]`

- **初始值**：当对象在创建时获得一个特定的值，对象就被初始化了。
- **特别注意，初始化中的等号跟赋值中的等号完全不同。初始化的含义是在创建变量时赋予其一个初始值。而赋值的含义是把对象当前的值擦除，而以一个新值代替。**
- **列表初始化(C11新标准)**：`type variable_name{value}`, 当用于内置类型的变量时，如果使用列表初始化且初始值存在丢失信息的风险时，编译器会报错
- **默认初始化**:如果定义变量时没有指定初值，则变量被默认初始化。一个未被初始化的内置类型变量的值是未定义的；而每个类各自决定其初始化对象的方式
- 函数体外部定义的变量一般存放在固定地址中，而函数体内部定义的变量并非如此

### 2.2.2 变量的声明和定义

```C++
extern int i; //声明i
int j; //声明并定义j
extern double p = 3.1415 //定义
```

1. 为了支持分离式编译，C++语言将声明和定义区分开。**声明(declaration)** 使得名字为程序所知，一个文件如果使用别处定义的名字则必须包含那个名字的声明。而**定义(definition)** 负责创建与名字关联的实体。
2. 如果想声明一个变量需要在变量名前添加关键字`extern`,extern语句如果包含初始化就不再是声明，而是变成了定义
3. 变量只能被定义一次，但可以多次声明

### 2.2.3 标识符

1. C++的标识符由数字、字母、下划线组成，其中必须以字母或下划线开头，标识符对长度没有限制但对大小写敏感;
2. 不能使用C++关键字、不能出现两个连续的下划线、不能以下划线紧连大写字母、定义在函数体外的标识符不能以下划线开头
2. 变量命名规范
	1. 标识符要能体现实际含义
	2. 变量名一般用小写字母，不能使用形如Index或者INDEX
	3. 用户自定的类型一般以大写字母开头，如Sale_item
	4. 如果标识符由多个单词组成，则单词之间应该有明显区分，如student_loan或StudentLoan

### 2.2.4 名字的作用域

在程序中，名字指向一个特定的实体：变量、函数、类型等，而**作用域(scope)** 限制了名字的有效区域，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端结束。作用域以花括号分隔。

**全局作用域和块作用域**
	1. 定义在所有花括号之外的名字具有全局作用域，全局作用域的名字在整个程序内部都可使用
	2. 定义在花括号之内的名字具有块作用域，只能在块内起作用，

**嵌套作用域**
	作用域能够彼此包含，称为**内层作用域**和**外层作用域**，在外层作用域定义的名字内层作用域可以使用，而在内层作用域定义的名字外层则不可使用，在内层作用域定义的同名局部变量会覆盖外层的变量

**如果函数可能使用到某个全局变量，则不宜在定义一个同名的局部变量**

## 2.3 复合类型

***基于其他类型定义的类型称为复合类型***

### 2.3.1 引用

**引用(reference)** 为对象起了另一个名字，写法为在类型名前加上`&`符
```C++
	int val = 10;
	int &refval = val;
```

- **要点**
		1. 不存在空引用。引用必须连接到一块合法的内存。
		2. 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
		3. 引用必须在创建时被初始化。指针可以在任何时间被初始化。
		4. 引用不是一个对象，所以不存在引用的引用
		5. 引用的类型要和与之绑定的对象严格匹配，而且引用只能绑定在对象上。不能是字面值

### 2.3.2 指针

1. **指针(point)** 是指向另一种类型的复合类型，指针本身就是一个对象，且无需在定义时赋初值。**但是未初始化的指针的值是未定义的**
2. 定义指针的方法为：`int *p;`
2. 指针储存的是对象的地址，可以利用取地址符`&`获取对象的地址:`int *p = &val`
3. 利用指针访问对象：`int val = *p`,此时的`*`号称为解引用符，解引用操作只适用于那些指向了对象的指针
4. **空指针(null point)** 不指向任何对象：`int *p = nullptr`
5. **指针的值应属于下列四种状态之一**
		1. 指向一个对象
		2. 指向紧邻对象所占空间的下一个位置
		3. 空指针，意味着指针没有指向任何对象
		4. 无效指针，上述情况之外的其他值。试图访问无效指针将引发错误
6. **指针和引用的区别**：指针和引用都能提供对其他对象的间接访问，引用并非一个对象，一旦定义了引用就无法使其再绑定另一个对象。但是指针是对象，而且指针的指向可以被修改
7. **void\* 指针** :`void*`是一种特殊类型的指针，可以存放任意对象的地址，但是可用的操作比较有限，并不能直接操作`void*`指针的所指的对象，以`void*`的视角来看内存空间也仅仅是内存空间，没法访问内存空间中所存储的对象
8. 指向指针的指针：`int **p`,通过`*`的个数可以确定指针的级别
9. 指向指针的引用：指针是一个对象，所以定义指向指针的引用，反之引用不是一个对象，所以不存在指向引用的指针。`int *p = &u=i; int &ref = p;`

***建议初始化所有指针，如果可能，尽量在定义了对象之后再定义它的的指针***

## 2.4 const限定符
***利用`const`关键字来定义一个常量。因为常量不能被修改，所以`const`对象一旦创建后其值就不能再改变，所以const对象必须初始化***

### 2.4.1 const的引用

1. 默认状态下const对象仅在文件内有效: 在编译的过程中，编译器会将所有的const对象替换成对应的值，为了执行上述替换，编译器必须知道const对象的初始值，那么在用到该对象的文件中必须有对它的定义，所以在C++中const对象被设定为仅在文件内有效。如果要使const对象在文件间共享，则需要在变量的定义前加`extern`关键字
2. const的引用：对常量的引用不能被用作修改他所绑定的对象
	```C++
		const int cvalue = 19;
		const int &rc = cvalue;
	```
3. 默认情况下，引用的类型必须和所引用的对象保持一致，但是有两个例外，
	1. 第一个例外是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式能够转换成引用的类型，尤其是允许为一个常量引用绑定一个非常量的对象、字面值、一般表达式
	```C++
		double dval = 3.14;
		const int &ri = dval;
		//  此时ri引用的是一个int型的数，但是dval却是一个双精度浮点型的数，为了保证ri绑定的是一个整数，编译器进行了替换
		const int temp = dval;
		const int &ri = temp;
		//  在这种情况下ri绑定的是一个**临时量对象**，所谓临时量对象就是编译器需要一个临时空间来暂存表达式的求值结果
	```
	2. 当ri不是常量时，意味着可以通过ri改变所引用对象的值，但是ri引用的是一个临时量而非dval，既然创建了引用就是想通过引用修改所指向的对象的值，但是这种状况是无法修改的，所以C++将此类行为归为非法
3. ***注意：对const的引用仅对引用可参与的操作做了限定，而对所引用的对象本身是不是一个常量未作限定，因此对象可以是非常量，可以修改对象本身的值***

### 2.4.2 指针和const

- 与常量引用类似，也可以令指针指向常量，**指向常量的指针**不能用于改变其所指向的对象的值，指向常量的指针并没有规定其所指的对象必须是一个常量，只是不能通过该指针去改变所指对象的值，但是要想储存常量对象的地址，只能使用指向常量的指针
- 指针本身也是对象，所以可以令指针本身是常量，称为**常量指针(const pointer)**，把`*`放在const之前用来说明指针本身是一个常量，不能修改指针中所存储的地址， 也就是不能修改指针的指向，指针本身是一个常量并不意味这不能通过指针修改其所指的对象的值
```C++
	int val = 1;    //定义一个对象
	const int cval = 10;    //定义一个常量，其值不可修改
	const int *ptr = val;   //指向常量的指针，不能通过指针修改所指对象的值
	int *const ptr` = val;   //常量指针，不能修改指针的指向，但是可以修改所指对象的值
```

### 2.4.3 顶层const
**顶层const**表示指针本身是一个常量，即常量指针。**底层const**表示指针所指的对象是一个常量，const修饰的普通常量也是顶层const

### 2.4.4 constexpr和常量表达式
- **常量表达式(const expression)** 是指值不会改变的并且在编译过程就会得到计算结果的表达式。字面值、用常量表达式初始化的const对象也是常量表达式
- **constexpr** 变量：将变量声明为constexpr类型以便由编译器来验证变量的值是不是一个常量表达式
- 一般来说，如果你认定变量是一个常量表达式，那就声明为constexpr类型
- **字面值类型**：常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制，因为这些类型比较简单、值也显而易见，所有就把他们称为字面值类型。算术类型、引用、指针都属于此类，类类型则不属于字面值类型
- 注意：定义一个指针为constexpr类型，仅对指针本身有效，与指针指向的值无关
  
## 2.5 处理类型

### 2.5.1 类型别名
**类型别名(type alias)**: 用来简化复杂的类型名，两种方法创建类型别名
- 使用关键字`typedef`， 使用typedef定义的不再是变量而是类型别名
```C++
	typedef int zhengshu;    //zhengshu是int的别名
	typedef int* zhizhen;             //zhizhen是int*的别名
```
- 使用别名声明来定义类型的别名
```C++
	using zhegnshu = int;   //zhengshu是int的别名
	using zhizhen = int*;
```
- 易错点
```C++
	typedef char *pstring;
	const pstring cstr = nullptr;   //此时const修饰的是指向char的指针，也就是cstr是常量指针
```
### 2.5.2 auto类型说明符
- **auto**让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值
```C++
	auto i = 10;
	auto b = 3.15;
	auto c = `c`;
```
- auto会忽略顶层const,但底层const会保留
```C++
	const int i = 10;   //i是一个顶层const
	int j = 10;
	const int* p = &j    //p是一个底层const
	auto ai = i;       //i的顶层特性会被忽略
	auto ap = p;    //p的底层特性会被保留
```

### 2.5.3 decltype类型指示符

  - 类型说明符**decltype**会选择并返回操作数的数据类型，在此过程中编译器分析表达式并得到他的类型，却并不实际计算表达式的值
  - 如果decltye使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）
  - **注意**：decltype((variable))双层括号的结果永远是引用，而decltype(variable)结果只有当variable本身是引用是才是引用
```C++
	decltype( f() ) sum = x;     //sum的类型就是f()的返回类型
	int x = 10;
	int i  =10;
	const int ci = 100;
	int &ri = x;
	decltype(x) y = 20;    //y的类型就是x的类型
	decltype(ci) di = 2;    //di的类型就是ci的类型，并且因为ci是常量，所以di必须初始化
	decltype(ri) dri = x;    //dri就是x的引用
	decltype((x)) d = i;    //双层括号表示引用，此时d是int&类型
```

## 2.6 自定义数据结构
- **数据结构**：就是把一组相关的数据元素组织起来然后使用他们的策略和方法
- C++以类的形式自定义数据结构，类中包含属性和方法。属性就是数据元素，方法就是函数
- 在C++中类和结构体的区别
	- 类的关键字是`class`，结构体的关键字是`struct`
	- class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。
	- 从 class 继承默认是 private 继承，而从 struct 继承默认是 public 继承。
	- class 可以定义模板，而 struct 不可以。
	- C与C++结构体中前者不能有函数，后者可以有。
- 类的数据成员：类的数据成员定义了类的对象的具体内容，每个对象都有自己的一份数据成员拷贝，C++11标准中可以为数据成员提供一个**类内初始值**，以便在创建对象时初始化对象成员
  
### 2.6.1 定义一个数据结构
```C++
	struct type_name{
		member_type1 member_name1;
		member_type2 member_name2;
		.....
		member_function1();
		member_function2();
		......
	}object_name;   //结构体定义
	
	struct type_name object_name;   //结构体声明
	typedef struct type_name object_name2;    //C98及以前
```
- 注意事项1：**type_name** 是结构体类型的名称，`member_type1 member_name1` 是标准的变量定义，比如 `int i;` 或者 `float f;`或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。
- 注意事项2：在C中定义结构体变量需要使用`typedef`（C98以前），C++中不需要
- 注意事项2：C++在声明一个结构体变量时使用`typedef`带来的影响
	- 第一是不用 typedef：object_names 就相当于一个变量了，可以直接调用结构体中的内容
	- 第二种是用 typedef：object_names 部分是个结构体类型，在调用结构体之前必须创建结构体的变量
- 注意事项3：类右侧表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名，以示对该类型变量的定义
### 2.6.2 使用一个数据结构
- 通过成员访问运算符`.`来访问结构的成员
- `.`和`->`的不同：用结构体定义了一个实体，那么这个实体要访问他里面的成员，就用点操作符，如果用结构体定义的是一个结构指针，那么要访问他里面的成员就用箭头运算符。

  ### 2.6.3 使用头文件
  C++程序都是分离式编译，所有的预处理文件、常量、函数声明、类定义都放在头文件中
  - 确保头文件多次包含仍能安全工作的常用技术是**预处理器(preprocessor)**，预处理器是在编译之前执行的一段程序，以`#`开头
  - 使用头文件保护符来防止重复包含的发生
```C++
	#ifdef HEADNAME_H
	#define HEADNAME_H
	......
	#endif
```
  
  - 如果`#ifdef`为真，就执行接下来的语句直到`#endif`为止，否则就跳过
  - **无论头文件有没有被使用，头文件保护符都必须要有，且养成习惯**

  ![vector和数组](https://pan-yz.chaoxing.com/thumbnail/0,0,0/0ee2faa147d1e81564faed28e44245d2)
 

**关键概念**

1. 静态类型: C++是一种**静态类型(statically typed)**语言，其含义是在编译阶段检查类型。其中检查类型的过程称为**类型检查(type checking)**.在使用变量前声明类型有助于编译器发现问题

2. 在对象第一次被使用的地方附近定义它是一种好的选择
3. `int *p` 强调变量具有复合类型;`int* p`这样写强调定义了一种复合类型
4. `nullptr` 是一种特殊类型的字面值，他可以被转化为任意其他的指针类型，而`NULL`是一种预处理变量，在头文件`cstdlib`中定义，它的值就是0，在C++中最好使用nullptr,**尽量避免使用NULL**

---

title: "Cpp_day3"

date: 2022-01-02T16:45:37+08:00

draft: false

tag: ["C++"]

---

除了内置类型外，C++还提供了丰富的抽象数据类型库，包括string、vector等等

## 3.1 命名空间中的using声明

- **命名空间**：表示一个标识符的可见范围，用来区分不同库中相同的函数、类和变量。使用关键字`namespace`定义命名空间

```C++

namespace namespace_name{

namespace_body;

....

} //定义一个命名空间

namespace_name::namespace_body //使用命名空间中的成员

```

- **using指令**:使用`using namespace namespace_name`告诉编译器后续的代码将使用指定命名空间中的名称
- 位于头文件中的代码一般来说不应该使用using声明，因为头文件中的内容会拷贝到所有引用它的文件中去，如果头文件中有using声明，那么每个使用到该头文件的文件都会有这个声明，会导致一些错误

  

## 3.2 标准库类型string

- 标准库类型**string**表示可变长的字符序列，使用string类型必须包含string头文件：`#include<string>`
- `std::string`是在标准库`<string>`中提供的一个**类**，本质上是 `std::basic_string<char>`  的别称。

### 3.2.1 定义和初始化一个string对象

```C++

	string s1; //默认初始化，s1是一个空字符串

	string s2 = s1; //s2是s1的副本

	string s2(s1); //直接初始化

	string s3 = "value"; //s3是字面值“value”的副本，除了字面值最后的那个空字符外

	string s3("value"); //同上

	string s4(n,'c'); //把s4初始化为n个c组成的串

```

**直接初始化与拷贝初始化**

如果使用等号初始化一个变量，实际上执行的是拷贝初始化(copy initialization)，编译器把等号右侧的初始值拷贝到新创建的对象中去，与之相反，如果不使用等号，则执行的是直接初始化(direct initialization)

直接初始化就是直接调用类的构造函数来初始化对象，例如在string s3(“value”)中，string类的string(const char *)构造函数会被调用，s3被直接初始化。然而根据标准，复制初始化应该是先调用对应的构造函数创建一个临时对象，再调用拷贝构造函数将临时对象拷贝给要创建的对象。例如在string s3=”value”中，string类的string(const char *)构造函数会被首先调用，创建一个临时对象，然后拷贝构造函数将这个临时对象复制到a。

  

### 3.2.2 string对象上的操作

> 类既可以定义通过函数名调用的操作，也可以定义各种运算符在该类对象上的新含义

| 操作 | 含义 |

| --------------- | -------------------------------------------- |

| `os<<s` | 将s写入到输出流os中，返回os |

| `is>>s` | 从is读取字符串赋给s,字符串以空白间隔，返回is |

| `getline(is,s)` | 从is中读取一行赋给s |

| `s.empty()` | s为空返回true,否则返回否则返回false |

| `s.size()` | 返回s中字符的个数 |

| `s[n]` | 返回s中第n个字符的引用，n从0计 |

| `s1+s2` | 返回s1和s2连接之后的结果 |

| `s1=s2` | 用s2的副本代替s1原来的字符 |

| `s1==s2` | 判断s1和s2是否相等，对大小写敏感 |

| `<,<=,>,>=` | 利用字符在字典中的顺序进行比较 |

  

**读写string对象**

从标准输入读取内容到字符串中:`std::cin >> str;`。注意string对象会自动忽略开头的空白，从第一个真正的字符开始，直到遇到下一个空白

```C++

int main(){

string word;

string line;

while(cin >> word)

cout << word << endl; //读取未知数量的string对象

while(getline(cin, line))

cout << line << endl; //使用getline读取一整行

return 0;

}

```

  

**string的empty和size操作**
- empty函数根据对象是否为空返回一个对应的布尔值
- size函数返回string对象的长度，返回值类型为`string::size_type`，这是一个无符号整型数，可以通过`auto`、`decltype`来推断变量的类型。切记不要把string::size_type类型的值和其他算术类型进行比较

**string对象的比较**：使用相等性运算符`==和!=`对两个string对象进行比较,相等为真，逐个字符比较且对大小写敏感


**字面值和string对象相加**：当把string对象和字符串字面值相加时，必须保证每个假发运算符的两侧至少有一个是string对象

字符串字面值和并不是标准库类型string的对象

**处理string对象中的字符**

使用`<cctype>`头文件中的函数来处理字符

| 函数 | 功能 |

| ------------- | ------------------------------------------------- |

| `isalnum(c)` | 当c是字母或数字时为真 |

| `isalpha(c)` | 当c是字母时为真 |

| `iscntrl(c)` | 当c是控制字符时为真 |

| `isdigit(c)` | 当c是数字时为真 |

| `isgraph(c)` | 当c不是空格但可打印时为真 |

| `islower(c)` | 当c是小写字母时为真 |

| `isprint(c)` | 当c是可打印字符是为真 |

| `ispunct(c)` | 当c是标点符号时为真 |

| `isspace(c)` | 当c是空格时为真 |

| `isupper(c)` | 当c是大写字母是为真 |

| `isxdigit(c)` | 当c是十六进制数字时为真 |

| `tolower(c)` | 如果c是大写字母，输出对应的小写字母，否则原样输出 |

| `toupper(c)` | 如果c是小写字母，输出对应的大写字母，否则原样输出 |

  
**使用基于范围的for语句处理每一个字符(C++11)**

范围for语句，这种语句便利给定序列中的每一个元素并对序列中的每一个值执行某种操作，语法形式为：

```C++

for(declaration:expression)

statement;

```

`expression`是一个对象，用于表示一个序列，`declaration`负责定义一个变量，该变量用于访问序列中的基础元素，每次迭代，declatation部分的变量会被初始化为expression部分的下一个元素值

***注意：范围for语句体内不应改变其所遍历序列的大小***

**使用下标或称索引访问string对象中的元素**：`str[n]`，下标从0计

## 3.3 标准库类型vector(一种容器container)

- 标准库类型`vector`表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，通过索引访问对象，要想使用vector必须包含头文件`<vector>`
- vector是一个模板而非类型，由vector生成的类型必须包含vector中元素的类型，比如`vector<int>`
- 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。

### 3.3.1 定义和初始化vector对象

| 方法 | 功能 |

| ------------------------------ | -------------------------------------------------------- |

| `vector<T> v1` | v1是一个空vector,它潜在的元素类型为T，执行的是默认初始化 |

| `vector<T> v2(v1)` | v2中包含v1所有元素的副本 |

| `vector<T> v2 = v1` | 与上面相同 |

| `vector<T> v3(n,val)` | v3包含n个重复的元素，每个元素的值都是val |

| `vector<T> v4 = {a,b,c,d,...}` | v4包含初始值个数的元素，每个元素都被赋予相应的初始值 |


**列表初始化**：`vector<T> v5 = {a,b,c,d,...}`

**值初始化**：通常情况下，可以只提供vector对象容纳的元素数量而忽略初始值，此时会创建一个值初始化的元素初值并赋给容器中的所有元素，这个初值由vector对象中元素的类型决定。例如：`vector<int> ivec(10)`,表示创建10个元素，每个初始化为0，
- 注意：某些类明确要求需要初始值，就不能使用值初始化。
- 注意：如果要指定元素数量而不是设定初始值，那么必须采用直接初始化的形式来指定向量大小

**如何确定是列表初始化还是元素数量？**

在某些情况下，初始化的真实含义取决于传递初始值时用的是花括号还是圆括号，

```C++

vector<int> v1(10); //v1有10个元素，每个的值都是0

vector<int> v2{10}; //v2有1个元素，值为10

vector<int> v3(10,1); //v3有10个元素，每个的值都为1

vector<int> v4{10,1}; //v4有2个元素，分别为10,1

```


### 3.3.2 vector的操作

| 功能 | 操作 |

| ------------------------ | ------------------------------------------------ |

| `v.push_back(t)` | 向v的尾端添加一个值为t的元素 |

| `v.empty()` | 判空 |

| `v.size()` | 返回v中的元素个数 |

| `v[n]` | 返回v中第n个元素的引用 |

| `v1 = v2` | 用v2中的元素拷贝替换v1中的元素 |

| `v1 = {a, b, c, d, ...}` | 用列表中的元素拷贝替换v1中的元素 |

| `v1 == v2` | v1和v2元素数量且对应位置的元素值都相等时二者相等 |

| `<, <=, >, >=` | 以字典顺序进行比较 |


**不能用下标形式添加元素**

## 3.4 vector和数组的区别


![vector和数组](https://pan-yz.chaoxing.com/thumbnail/0,0,0/3f6f7d4eb330380ecc79e77acbca9172)

**注意事项**

1. 问题：如何做到只输出非空行
2. 问题：使用范围for语句统计标点符号的个数、将有的小写字母转换成大写形式
3. 模板本身不是一个类或者函数，相反可以将模板看成编译器生成类或函数编写的一份说明，编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型

---

title: "Cpp_day4"

date: 2022-01-04T16:03:50+08:00

draft: false

tags: ["C++"]

---


## 3.4 迭代器

- 除了下标之外，访问容器成员的另一种方法
- 除了vector之外，标准库还定义了其他几种容器，**所有的容器都可以使用迭代器**，但只有少数几种同时支持下标运算符。
- 严格来说string不属于容器，但是其支持与容器类似的操作，包括迭代器。

### 3.4.1 使用迭代器

- 有迭代器的类型，都有返回迭代器的成员。比如**begin**和**end**成员，begin成员返回指向第一个元素的迭代器，end成员返回指向容器尾元素的下一个位置的迭代器

- 尾元素的下一个位置并无实际含义，只是一个标记。表示已经处理完容器中的所有元素，end成员返回的迭代器称为**尾后迭代器**，如果容器为空则bengin和end返回的是同一个迭代器

```C++

auto iter1 = v1.begin(); //iter1的类型为vector<int>::iterator

auto iter2 = v1.end(); //同上
  

auto iter3 = v1.cbegin(); //iter3的类型为vector<int>::const_iterator

auto iter4 = v1.cend(); //同上

```


**迭代器的操作**

| 操作 | 功能 |

| ---------------- | ------------------------------------------------------ |

| `*iter` | 返回迭代器iter所指元素的引用 |

| `iter->mem` | 解引用iter并获取该元素名为mem的元素，等价于(*iter).mem |

| `++iter` | 令iter指向容器的下一个元素 |

| `--iter` | 指向容器上一个元素 |

| `iter1 == iter2` | 判断两个迭代器是否相等 |


**迭代器的类型**

事实上就像string和vector的size_type一样，我们并不知道迭代器精确的返回值类型，其实也无需知道那些拥有迭代器的标准库类型使用的是`iterator`和`const_iterator`来表示迭代器的类型

```C++

vector<int>::iterator it //it能读写vector<int>中的元素

string::iterator it2 //it2能读写string对象中的字符

  

vector<int>::const_iterator cit //cit只能读元素，不能写元素

string::iterator cit2 //cit2只能读字符，不能写字符

```

**迭代器和迭代器类型**
迭代器这个名词有三个不同的含义：可能是迭代器概念本身，也可能指容器定义的迭代器类型，还可能指某个迭代器对象


**结合解引用和成员访问操作**
- 解引用迭代器可以获得迭代器所指的对象，如果该对象的类型恰好是类，就可以进一步访问他的成员：`(*iter).mem`
- 为了简化操作，C++定义了**箭头运算符(->)**。箭头运算符把解引用和成员访问运算符结合起来，也就是说`iter->mem`=`(*iter).mem`
- 不能解引用尾后迭代器

### 3.4.2 迭代器运算


> 除了递增运算符和比较运算符外，string和vector提供了额外的运算符，所有的这些运算符称为**迭代器运算**

| 操作 | 功能 |

| --------------- | ------------------------------------------------------------------- |

| `iter + n` | 使迭代器向前移动n个元素，迭代器要么指向新的位置，要么指向尾后迭代器 |

| `iter + n` | 向后移动n个元素，迭代器要么指向新的位置，要么指向尾后迭代器 |

| `iter += n` | 迭代器的复合运算，将iter+n的结果赋给iter |

| `iter -= n` | 同上 |

| `iter1 - iter2` | 两个迭代器相减表示他们之间的距离，前提是这两个迭代器指向同一个容器 |

| `>, >=, <, <=` | 两个迭代器的位置比较，前提是这两个迭代器指向同一个容器 |

- 两个迭代器使用关系运算符进行比较，所得结果是两个迭代器之间的距离，返回值类型是名为**difference_type**的带符号整型数,
- 一些计算的例子
	- 计算v1中间的元素：`auto mid = v1.begin() + v1.size()/2`
	- 只处理v1前半部分：`if(it < mid)`
	- 使用迭代器完成二分查找

```C++

//v1必须是有序的

auto begin = v1.begin();

auto end = v1.end() - 1 ;

auto mid = v1.begin() + (end - begin)/2;

while(mid != end && *mid != source){

if(*mid > source)

end = mid;

else

begin = mid + 1;

mid = begin + (end - begin)/2;

}

```


**迭代器是什么？**
1. 迭代器是一种概念：一种访问容器中元素的方法
2. 迭代器是一种方法：每个容器都定义了迭代器这种方法（此方法非彼方法，这里更像是成员函数）
3. 迭代器是一种类型，迭代器的返回值是形如`vector<int>::iterator`的类型


**注意事项**

1. ***注意：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器中添加元素***

---

title: "Cpp_day6"

date: 2022-01-08T11:52:05+08:00

draft: false

---

# 4 表达式

> 表达式由一个或多个**运算对象(operand)**组成，对表达式求值将得到一个**结果(result)**,字面值和变量是最简单的**表达式(expression)**,其结果就是字面值和表达式的值，将**运算符(operator)**和一个或多个运算对象组合起来可以生成较复杂的表达式

## 4.1 基础

- 作用于一个运算对象的运算符是一元运算符，作用于两个运算对象的运算符是二元运算符
- 不同类型的类型的对象也可以进行运算，只要他们能被转换成同一类型即可，小整数类型(bool,char,short)通常被提升为较大的整数类型，比如int
- C++本身定义了运算读用于内置类型，但在类类型中，用户可以自定义运算符的含义，称为**重载运算符**
- **左值和右值**：当一个对象被用于右值的时候，用的是对象的值（内容），当一个对象被用于左值的时候，用的是对象身份（在内存中的位置）
- **优先级和结合律**：优先级高的运算符先运算，优先级相同的运算符满足左结合律，也就是从左到右的顺序运算,有括号的先计算括号内的

## 4.2 算术运算符


| 运算符 | 功能 | 用法 |

| ------ | -------- | ------------- |

| `+` | 一元正号 | `+ expr` |

| `-` | 一元负号 | `- expr` |

| --- | --- | --- |

| `*` | 乘法 | `expr * expr` |

| `/` | 除法 | `expr / expr` |

| `%` | 求余数 | `expr % expr` |

| --- | --- | --- |

| `+` | 加法 | `expr + expr` |

| `-` | 减法 | `expr - expr` |

- 运算符表都将按照优先级的形式进行分组，优先级从高到低
- 当一元正（负）号运算符作用于指针或者算术值时，返回运算对象的一个（提升后的）副本，
- 算术运算符能作用于任意算术类型，或者能转换成算术类型的类型，不能作用于布尔值
- 在进行算术运算时，注意不要使运算对象超过其所允许的最大值
- 取余/取模运算的两个运算对象必须是整数类型


## 4.3 逻辑和关系运算符


| 结合律 | 运算符 | 功能 | 用法 |

| ------ | ------ | -------- | --------------- |

| 右 | `!` | 逻辑非 | `!expr` |

| --- | --- | --- | --- |

| 左 | `<` | 小于 | `expr < expr` |

| 左 | `<=` | 小于等于 | `expr <= expr` |

| 左 | `>` | 大于 | `expr > expr` |

| 左 | `>=` | 大于等于 | `expr >= expr` |

| --- | --- | --- | --- |

| 左 | `==` | 等于 | `expr == expr` |

| 左 | `!=` | 不等于 | `expr !== expr` |

| --- | --- | --- | --- |

| 左 | `&&` | 逻辑与 | `expr && expr` |

| 左 | `||` | 逻辑或 | `expr || expr` |


- 对逻辑与运算符(&&)来说,当两个对象都为真时结果为真. 当且仅当左侧运算符为真时才对右侧运算符求值
- 对逻辑或(||)运算符来说,有一个为真结果就为真. 当且仅当左侧运算符为假时才对右侧运算符求值
- 逻辑非运算符将运算结果取反后返回
- 关系运算符,满足左结合律,返回的是布尔值. 进行比较运算时,除非比较的对象是布尔值,否则不要使用布尔值字面量`true`和`false`作为运算对象


## 4.4 赋值运算符

- 赋值运算符的左侧运算对象必须是一个可修改的左值
- 如果左右两个运算对象的类型不同,右侧的运算对象将转换成左侧运算对象的类型
- 赋值运算满足右结合律
- 赋值运算符优先级较低

## 4.5 递增和递减运算符

- 递增运算符(++)和递减运算符(--)为对象加一和减一,特别指出递增和递减可以用于迭代器
- 递增和递减有两种类型,前置和后置,
- 前置版本:首先将运算对象加一,然后将改变后的对象作为求值结果
- 后置版本:求值结果是运算对象改变前的副本,然后运算对象加一
- 验证代码:`cout << ++i;`和`cout << i++;`

**除非必须,否则不使用递增递减的后置版本**
- 前置版本的递增运算符避免了不必要的工作,他把值加一后直接返回了改变后的运算对象,而后置版本需要先将原始值存储下来以便返回这个未修改的内容

**在一条语句中混用解引用符和递增运算符**
- `*pedg++`根据优先级看:`*(pedg++)`,过程为:先把pedg的值加一,然后返回pedg的初始值的副本作为其求值结果,此时解引用的操作对象为pedg未增加之前的值
- 所以这条语句的实际结果为:输出pedg的值然后将pedg向后移动一个位置

## 4.6 成员访问运算符

- 成员访问运算符(.):点运算符获取类对象, 结构体, 联合的一个成员,如果成员所属的对象是左值,则结果是左值,如果成员所属的对象是右值,则结果是右值
- 成员访问运算符(->):箭头运算符作用一个指针类型的运算对象,相当于`(*ptr).mem`, 结果是一个左值

## 4.7 条件运算符

- 条件运算符`(cond ? expr1 : expr2)`是唯一的三元运算符,如果cond为真则执行expr1,否则执行expr2
- 可以嵌套条件运算符,也可以在输出表达式中使用田间运算符


## 4.8 位运算符


> 位运算符作用于整数类型的运算对象, 并把运算对象看作是二进制位的集合, 位运算符提供检查和设kjmiiuok置二进制位的功能
> 一般来说,如果运算对象是小整型则他的值会被自动提升为较大的整数类型,提升过程原来的位保持不变,向高位添加0即可

| 运算符 | 功能 | 用法 |

| ------ | ------ | ------------------------ |

| `~` | 位求反 | `~ expr` |

| --- | --- | --- |

| `<<` | 左移 | `expr1 = expr1 << expr2` |

| `>>` | 右移 | `expr1 = expr1 >> expr2` |

| --- | --- | --- |

| `&` | 位与 | `expr1 & expr2` |

| --- | --- | --- |

| `^` | 位异或 | `expr1 ^ expr2` |

| --- | --- | --- |

| `|` | 位或 | `expr1 | expr2` |

  

**移位运算符**
- `<<`和`>>`这两种运算符的内置含义是对其运算对象进行基于二进制位的移动操作
- 首先让左侧的运算对象按照右侧运算对象的要求移动指定位数,然后将经过移动的左侧运算对象的拷贝作为求值结果
- 右侧的运算对象一定不能为负,
- 二进制的左移或者右移,移出边界之外的位就被舍弃掉了
- 左移运算符在右侧插入值为0的二进制位,如果右移运算符的运算对象是无符号类型,则在左侧插入0,如果是有符号类型,则视情况而定

**位求反运算符**
- 位求反运算符(~)将运算对象逐位求反后生成一个新值,将1置为0,将0置为1

  

**位与,位或,位异或运算符**
- 对于位与(&)运算符来说,如果两个运算对象的对应位置都是1,则结果为1,否则为0
- 对于位或(|)运算符来说,如果两个运算对象对应位置至少有一个为1,则结果为1,否则为0
- 对于位异或(^)运算符来说,如果两个运算对象有且只有一个1,则结果为1,否则为0

  

**位运算符的使用**
- 测试一个班级内30个学生的测试成绩是否通过,则全班的测试结果可以用一个无符号整数来表示:`unsigned long quiz1 = 0;`,给这个quiz1赋一个初始值,使每一个位表示一个学生结果,
- 假如要设置第27个学生通过测试,就设置一个值,该值只有第27位为1,其余都是0.将该值与quiz1进行位与运算,就可以将第27个学生的结果设置为1
- 移位运算符满足左结合律

  

## 4.9 sizeof运算符

- sizeof运算符返回一条表达式或者一个类型名所占的字节数,sizeof运算符满足右结合律,其所得的值是一个`size_t`类型的常量表达式,

- sizeof并不实际计算其运算对象的值

```C++

sizeof(type);

sizeof expr; //sizeof返回结果类型的大小

  

sizeof *p; //返回的是p所值对象的类型大小,这里无需关系p的指向

```

## 4.10 逗号运算符

- 逗号运算符(,)含有两个运算对象,按照从左到右的顺序依次以此求值,首先对左侧的运算对象求值,然后将运算对象丢掉,逗号运算符真正的的结果是右侧表达式的值

## 4.11 类型转换

不同类型但是可以**相互转换**的两种运算对象,在进行计算时,会先转换成相同的类型再进行计算

**何时发生隐式类型转换**

- 在大多数表达式中,比int类型小的整型值首先提升为较大的整数类型
- 在条件中,非布尔值转换为布尔值
- 初始过程中,初始值转换成变量的类型,在赋值语句中,右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算有多种类型,需要转换成同一中类型
- 函数调用时也会发生类型转换

  

### 4.11.1 算术转换

  

**整型转换**

- 把小整数类型转换成较大的整数类型, 对于`char, signed char, unsigned char, short, unsigned short, bool`, 会提升为`int`类型, 如果存放不了,则会转换为`unsigned int`类型. 较大的char类型会提升为`int, unsigned int, long, unsigned long, long long, unsigned long long`中最小的一种类型,
- 整型和浮点型一起运算时,会把整型转换为浮点型

  

**无符号类型的运算对象**

- 如果一个运算对象是无符号类型,另一个运算对象是有符号类型的,
- 无符号类型不小于带符号类型,则带符号类型的运算对象将被转换成无符号类型的
- 无符号类型小于带符号类型,如果无符号类型的所有值都能存储在该带符号类型中,则无符号类型转换为带符号类型,如果不能,那么带符号类型转换为无符号类型

  

### 4.11.2 其他隐式类型转换

- 数组转换成指针:在大多数用到数组的表达式中,数组自动转换为指向数组首元素的指针. 当数组用作decltype关键字的参数, 或作为取地址符, sizeof参数, 用一个引用初始化数组时都不会转换. 在数组作为函数类型时会转换
- 指针的转换:常量整数值0和字面值nullptr能转换成任意指针类型,指向任意非常量的指针能转换为`void*`, 指向任意对象的指针能转换成`const void*`,
- 转换成布尔类型:如果指针或算数类型的值为0,则转换结果是false, 否则结果是true
- 转换成常量:指向非常量类型的指针可以转换成指向常量类型的指针,包括引用. 即如果一个指针指向T, 则可以转换为指向const T

  

### 4.11.3 显式转换

如果必须,则可以显式的将对象强制转换成另一种类型, 称为强制类型转换. 具体为:`cast-name<type>(expression)`. 其中`type`是转换的目标类型, `expression`是要转换的值,`case-name`是static_cast, dynamic_cast, const_cast, reinterpret_cast的一种, cast-name指明执行的哪种转换

- **static_cast**:任何具有明确定义的类型转换, 只要不包括底层const,都可以使用static_cast
- **dynamic_cast**:支持运行时类型识别(p730)
- **const_cast**:只能改变运算对象的底层const,不能改变对象的类型. 使用const_cast可以去掉对象的const性质,如果对象本身不是一个常量, 使用强制类型转换获得写权限是合法的行为, 如果对象本身是一个常量,使用const_cast执行写操作就会产生未定义的后果
- **reinterpret_cast**:为运算对象的位模式提供较低层次的重新解释,

  

```C++

int x;

const char *pc;

//使用static_cast

double dx = static_cast<double>(x);

char *p = const_cast<char*>(pc); //正确,但是通过p写值是未定义的行为

const_cast<string>(pc); // 错误,const_cast只修改常量属性,不能修改对象类型

```

  

## 4.12 运算符优先级表

![](https://pan-yz.chaoxing.com/thumbnail/0,0,0/23e07d61b91c465fda4417dd5e0c284e)


**注意事项**

1. 简洁是一种美德, 尽量简化你的代码
2. 关于有符号位如何处理没有明确规定,强烈建议仅将位位运算符用于处理无符号类型
3. 强制类型转换干扰了正常的类型检查,程序应避免使用强制类型转换

---

title: "Cpp_day7"

date: 2022-01-10T14:23:44+08:00

draft: false

tags: ["C++"]

---


# 5 语句

## 5.1 简单语句

- 语句顺序执行,且以分号结尾.关键在于使用控制流语句以支持复杂的执行路径
- **空语句**:当在程序中,语法上需要一条语句,逻辑上不需要,此时就应该使用空语句,一般情况是,当循环的全部工作在条件部分就可以完成时,就需要用到空语句
- **复合语句**:是指用花括号括起来的语句和声明的序列,也被称为**块(block)**,一个块被就是一个作用域,当在程序中,语法上需要一条语句,逻辑上需要多条语句时,则应该使用复合语句

## 5.2 作用域

可以在if, switch, while, for语句的控制结构内定义变量, 定义在控制结构当中的变量只在相应语句只在内部可见,一旦语句结束,变量也就超出了作用范围了

## 5.3 条件语句

### 5.3.1 if语句

```C++

if(condition){

statement1;

......;

}else{

statement2;

......;

}

```

如果condition为真就执行statement1, 如果condition为假, 就执行statement2.

### 5.3.2 switch语句

```C++

switch(expression){

case constant-expression :

statement(s);

break; // 可选的

case constant-expression :

statement(s);

break; // 可选的

// 您可以有任意数量的 case 语句

default : // 可选的

statement(s);

}

```

- switch语句中的`expression`必须是一个整型或枚举类型，或者是一个class类型，其中class有一个单一的转换函数将其转换为整型或枚举类型。
- 在一个switch中可以有任意数量的case语句。每个case后跟一个要比较的值和一个冒号。
- case 的`constant-expression`必须与switch中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于case中的常量时，case后跟的语句将被执行，直到遇到`break`语句为止。
- 当遇到`break`语句时，switch终止，控制流将跳转到switch语句后的下一行。
- 不是每一个case都需要包含 break。如果case语句不包含break，控制流将会继续后续的case，直到遇到break为止。
- 一个switch语句可以有一个可选的`default case`，出现在switch的结尾。default case可用于在上面所有case都不为真时执行一个任务。default case中的break语句不是必需的。

- **一般不要省略case分支最后的break语句,即使不准备在default标签下任何事情,定义一个default标签也是有必要的**

## 5.4 迭代语句

### 5.4.1 while语句

```C++

while(condition)

{

statements;

......;

}

```

- 只要给定的条件为真，while 循环语句会重复执行一个目标语句。
- 定义在while条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程

### 5.4.2 传统的for语句

```C++

for(init-statement;condition;expression){

statements;

......;

}

```

- **传统for循环的执行流程**
	1. 循环开始时, 首先执行一次*init-statement*, 用于初始化一个值,这一步只在开始时执行一次.
	2. 接下来判断*condition*, 如果条件为真,就执行一次循环体,否则循环终止,如果第一迭代时条件就为假,那么循环体一次也不会执行
	3. 最后执行*expression*
- **for语句头的多重定义**: 和其他声明一样,*init-statement*可以定义多个对象,但是只能有一条声明语句,因此所有变量的基础类型必须相同
- **省略for语句头的某些部分**:for语句头能省略掉*init-statement*, *condiion*, *expression*, 中的任何一个,但要保留分号

### 5.4.3 范围for语句


```C++

for(declaration:expression)

statement;

```

- 用于遍历容器或其他序列中的所有元素
- *expression*必须是一个序列,要拥有能返回迭代器的begin和end成员
- *declaration*定义一个变量,序列中的每个元素都要能够转换成该变量的类型, 确保类型相容最简单的办法是使用auto类型说明符
- 如果要对序列中的元素进行写操作,循环变量必须声明为引用类型
- 每次迭代都会重新**定义**循环控制变量,将其**初始化**为序列中的下一个值, 之后执行*statement*,直到所有元素都处理完后循环终止


**范围for语句的定义来源和与之等价的传统for语句**

```C++

for(auto beg = v.begin()),end = v.end();beg != end;++beg){

auto &r = *beg; //如果有引用的话

statements;

}

```

- 由此可知为什么范围for语句不能修改容器的大小, 因为在范围for语句中已经预存了end()的值,

### 5.4.4 do while语句

```C++

do

statement;

while(condition);

```

- 先执行循环体, 然后在判断条件,不管条件是否为真,都要先执行一遍循环
- do while语句应该在条件后面用一个分号表示语句结束
- 因为是先执行循环体再判断条件,所以不能在条件部分定义变量

## 5.5 跳转语句

### 5.5.1 break语句

**break语句**负责终止离他最近的while, do while, for,或者switch语句, 并从这些语句之后的第一条语句开始执行

### 5.5.2 continue语句

**continue语句**终止最近的循环中的当前迭代并立即开始下一次迭代,只能出现在for, while和do while语句中,作用于离他最近的循环

### 5.5.2 goto语句

- **goto语句**的作用是从goto语句无条件跳转到同一函数内的另一条语句.语法形式为:`goto label;`,
- 标签标识符独立于其他变量,所以可以和同名变量共存
- goto语句不能绕过带初始化的变量定义
- **goto语句使得程序更加复杂且不利于理解,所以不要在程序中使用goto语句**

```C++
begin:
int sz = get_size();
if(sz <= 0)
goto begin;
```

		  
		  
---
title: "Cpp_day8"
date: 2022-01-14T17:04:53+08:00
draft: false
tags: ["C++"]
---
# 6 函数

## 6.1 函数基础
- 一个典型的函数定义包括以下几个部分: *返回类型*, *函数名字*, *由0个或多个形参组成的列表*和*函数体*. 形参列表用圆括号,圆括号内是用逗号隔开的形参,函数体用花括号
- 通过**调用运算符**来执行函数. 调用运算符的形式是一对圆括号,作用于一个表达式,该表达式是一个函数或指向函数的指针,圆括号内是用逗号隔开的实参
- **调用函数**: 函数调用完成两项工作,一是用实参初始化函数对应的形参;二是将控制权转移给被调函数,此时主调函数的执行暂时被中断,被调函数开始执行
- **return语句**:和函数调用一样,return语句也完成两项工作,一是返回return语句中的值;二是将控制权从被调函数转移到主调函数
- **实参和形参**:实参是形参的初始化,实参的类型必须和对应的形参相匹配
- **函数的形参列表**:函数的形参列表可以为空,但是不能省略,也可以使用void关键字来表示函数没有形参.形参之间用逗号隔开
- **函数的返回类型**:大多数类型都能用作函数的返回值,但是不能返回数组和函数类型,可以返回指向函数或数组的指针

### 6.1.1 局部对象

- 在C++语言中,名字有作用域,对象有生命周期
	- 名字的作用域是程序文本的一部分,名字在其中可见
	- 对象的生命周期是程序执行过程中该对象存在的一段时间
- 函数体是一个语句块,块构成一个新的作用域,我们可以在其中定义新的变量,形参和函数体内部定义的变量统称为**局部变量**,仅在函数的作用域内可见,同时局部变量还会**隐藏**在外层作用域同名的其他所有声明
- 在函数体外创建的对象存在于程序的整个执行过程中,此类对象在程序启动时被创建,直到程序执行结束时才被销毁,局部变量的声明周期依赖于定义的方式
  1. **自动对象**:普通的局部变量,当函数的控制路径经过变量定义语句时创建对象, 到达定义所在的块尾时销毁,对象只存在于块的执行期间.
  2. **局部静态对象**:用`static`关键字声明,在程序执行路径第一次经过对象定义语句时初始化,直到程序终止才被销毁

### 6.1.2 函数声明

- 函数在使用之前必须先声明,函数的声明不用包含函数体,也无需包含形参的名字,形式为:`int func();`
- **在头文件中进行函数声明**

### 6.1.3 分离式编译

- *分离式编译*允许我们把程序分割到几个文件中去,每个文件独立编译
- 把程序的各个功能分别储存在不同的文件中
- **编译和链接多个源文件**:`gcc main.cpp 1.cpp 2.cpp ...`, main函数中用到了1和2文件的函数,所以要放在一起编译,记得写头文件

## 6.2 参数传递
> 形参初始化的机理和变量初始化一样
### 6.2.1 传值参数

- 当实参的值被拷贝给形参时, 形参和实参是两个独立的对象,我们说这样的实参被**值传递**,或者函数被传值调用
- 函数对形参所作的所有操作都不会影响实参
- **指针形参**: 指针的行为和其他非引用类型一样,当执行指针拷贝操作时,拷贝的是指针指向的值,指针本身并没有改变.拷贝之后,两个指针仍然是不同的指针,因为指针可以使我们间接的访问它所指的对象,所有通过指针可以修改它所指对象的值
- **C中常常使用指针类型的形参访问函数外部的对象,在C++中建议使用引用类型的形参代替指针**

### 6.2.2 传引用参数

- 对引用的操作实际是作用在引用所引的对象上, 通过使用引用形参, 可以使得函数改变实参的值
- **使用引用避免拷贝**, 特别是对一些大的对象而言.
- **如果函数无需改变引用形参的值,最好将其声明为常量引用**
- 通过引用形参可以返回额外的信息
- 
### 6.2.3 const形参和实参
  - 顶层const作用于对象本身, 当用const实参区去初始化形参时,顶层const

### 6.2.4 数组形参
### 6.2.5 main函数的参数



## 6.3 返回类型和return语句
## 6.4 函数重载
## 6.5 特殊用途语言特性
## 6.6 函数匹配
## 6.7 函数指针

