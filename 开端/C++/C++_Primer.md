# 1.开始
## 1.1 一个简单的C++程序
```C++
#include<iostream>
int main(){
	std::cout << "hello world" << std::endl;
	return 0;
}
```
- `#include<iostream>`：预处理命令，在程序的预处理阶段将指定的标准库复制到当前文件中；
- 函数：包括**返回类型**，**函数名**，**形参列表**， **函数体**四部分:
	- main函数的返回类型必须为`int`，main函数的返回值被用来指示状态，0表示成功，非0的返回由系统定义;
	- 函数名建议驼峰命名法;
	- 形参的值可以在形参列表中初始化;
	- 用花括号括起来的部分称为函数体;
- 命名空间：命名空间可以避免使用不同库中相同名字导致的冲突标准库中定义的所有名字都在命名空间std中

## 1.2 输入输出
- C++本身没有定义任何输入输出，而是用标准库来提供IO机制；
- `iostream`标准库提供`istream`和`ostream`两个基础类型，表示输入流和输出流，一个流就是一个字符序列；
- 标准库定义了四个IO对象：`cin`标准输入、`cout`标准输出、`cerr`标准错误输出、`clog`日志；
- 输出运算符`<<`，将右边的运算对象写入到左边，注意左侧的运算对象必须是一个ostream对象；
- 输入运算符`>>`类似
- **缓冲区**：每个输出流都管理一个缓冲区，用来保存程序读写的数据。字符在串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。缓冲刷新的原因有很多，程序正常结束，作为main函数return操作的一部分，缓冲区被刷新；缓冲区满时刷新缓冲区，使用操作符如`endl`显式刷新缓冲区等；

## 1.3 控制语句
### 1.3.1 循环
- while循环
```C++
while(condition){            //如果为真，就执行语句
	statement(s);
}
```
- do..while循环
```C++
do{                         //先执行循环再进行判断
	statements;
}while(condition)
```
- for循环
	- for循环的控制流
		- **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
		- 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
		- 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
		- 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。
	```C++
	for( init; condition; increment){
		statement(s);
	}
	```
- 循环控制语句
	- break语句：终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。
	- continue语句：引起循环跳过主体的剩余部分，立即重新开始测试条件。
	- goto语句：将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。
### 1.3.2 判断
- if语句
```C++
if(boolean_expression){
	statement1;                    //如果条件为真就执行语句1
}else{
	statement2；                   //如果条件为假就执行语句2
}
```
- switch语句
	- switch必须遵循以下规则
		- **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
		- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
		- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
		- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
		- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
		- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 _继续_ 后续的 case，直到遇到 break 为止。
		- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。
```C++
switch(expression){
	case constant-expression : 
	statement(s);
	break;    // 可选的 
	case constant-expression : 
	statement(s); 
	break;    //可选的 
	//您可以有任意数量的 case 语句
	default : // 可选的 
	statement(s);
}
```

## 1.4 类简介
- 通过定义类来定义一个数据结构（相互之间存在一种或多种特定关系的数据元素的集合）
- 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。
- 类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。
![类](https://gitee.com/zyanjun/img_service/raw/master/img/cpp_object_class.png)
- 通过使用`.`操作符来访问类的成员

## 1.5 编译运行程序
在linux中使用g++来编译C++程序，具体命令为:`g++ source.cpp`，默认生成的可执行文件名为`a.out`,使用`-o`参数指定文件名








---

title: "C++_day2"

date: 2021-12-28T12:09:53+08:00

draft: false

tags: ["C++"]

---

  

# 2. 变量和基本类型

  

## 2.1 基本内置类型

> C++本身定义了一套算数类型和空类型(void),算数类型包括字符、整型、布尔值和浮点数，空类型不对应具体的值
> 在不同的机器上算数类型的具体大小也不相同，C++只定义了最小尺寸

### 2.1.1 算数类型
  
(以下示例是在64位机上)
| 类型        | 含义           | 最小尺寸            |
| ----------- | -------------- | ------------------- |
| int         | 整形           | 32位                |
| long        | 长整形         | 64位                |
| long long   | 长长整形       | 64位                |
| short       | 短整型         | 16位                |
| char        | 字符型         | 8位                 |
| wchar_t     | 宽字符         | 32位                |
| char16_t    | Unicode字符    | 16位                |
| char32_t    | Unicode字符    | 32位                |
| float       | 单精度浮点型   | 32位，6位有效数字   |
| double      | 双精度浮点型   | 64位，10位有效数字  |
| long double | 扩展精度浮点型 | 128位，10位有效数字 |
| bool        | 布尔类型       | 8位                 |

+ 一个char类型应该保证能够表示任意字符对应的数字值
+ 在C++中，一个int至少和一个short一样大；一个long至少和一个int一样大；一个long long至少和一个long一样大

**带符号类型和无符号类型**
	+ 除了布尔类型和拓展的字符型之外，其他的整形可以划分为带符号的(signed)和无符号的(unsigned)，带符号的可以表示正数、负数和零；无符号类型仅能表示大于零的值
	+ 类型int、short、long、long long、都是带符号的，在这些类型名前添加unsigned来声明无符号数。类型unsigned int可以缩写为unsigned.
	+ 与整形不同，字符型被分为三种：char、signed char、unsigned char.这三种并不一样，但表现形式只有带符号和无符号两种。其中char的类型是哪一种由编译器决定
	+ 无符号类型的所有比特都用来储存值，例如8比特的unsigned char可以表示0-255之间的值，而8比特的signed char可以表示-128 - 128之间的值

**如何选择类型**

***对不同的数据应该选择不同的数据类型，从而简化选择的过程***
	- 如果明知其值不可能为负，则应该选择无符号类型
	- 使用int进行整数运算，short通常太短而long通常和int有一样的尺寸，如果数值超过的int的范围，则应该选择long long类型
	- 在算数表达式中不要使用char或者bool类型，因为在某些编译器中char是无符号的，在另一些编译器中是带符号的，如果需要不大的整数应该使用signed char或者unsigned char
	- 执行浮点运算时，通常使用double,因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几

**基本内置类型的机器实现**
+ 计算机以比特序列来存储数据，大多数计算机以2的整数次幂作为块来处理内存，可寻址的最小内存块称为**字节(byte)**，存储的基本单元称为**字(word)**,一个字包含几个字节，大多数计算机将每一个字节和一个数字（称为地址）关联起来，

### 2.1.2 类型转换
  
***对象的类型定义了对象能够包含的数据和能参与的运算。当程序的某处使用了某种类型而对象应该取另一种类型时程序会自动进行类型转换，具体过程如下***
	+ 当把一个非布尔类型的算数值赋给布尔类型时，任何非零的数都为真，零为假;
	+ 当把一个浮点数赋给一个整数时，小数点之后的位将被舍弃;
	+ 当给一个无符号类型的数一个超出其表示范围的值时，结果是初始值对无符号类型表示数值总数取模之后的余数
	+ 当给一个带符号类型的数一个超出其表示范围的值时，结果是未定义的;

**总结：避免无法预知和依赖实现环境的行为**

### 2.1.3 字面值常量

***形如 42 的值被称为字面值常量(literal)，叫字面值是因为只能用值来称呼它，常量表示其不能被修改。每种字面值常量都表示一种数据类型***

1. **整形和浮点型字面值：**
	1. 十进制字面值的类型是int、long、long long中能容纳其数值的尺寸最小者；八进制和十六进制字面值的类型是int, unsigned int, long, unsigned long, long long, unsigned long long中能容纳其数值的尺寸最小者，类型short没有对应的字面值
	2. 尽管十进制字面值可以存储在带符号数据类型中，但是严格来说十进制字面值不会是负数，如果使用了一个形如 -42 的负十进制字面值，那么负号并不在字面值之内，其作用仅是对字面值取反而已
	3. 浮点型字面值表示为一个小数或以科学计数法表示的指数
2. **字符和字符串字面值**
	1. 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符称为字符串字面值
	2. 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾添加一个空字符('\0'),因此字符串字面值的实际大小比其内容大1
3. **布尔字面值和指针字面值**
	true和false是布尔类型的字面值；nullptr是指针类型的字面值

4. **转义序列**
1. 有两类字符并不能直接使用，一类是**不可打印字符(nonprintable)**，一类是在C++语言中有特殊含义的字符。在这种情况下需要用到**转译序列(escape sequence)** 来表示，转译序列以反斜杠作为开始
| 符号       | 转译序列 |
| ---------- |:--------:|
| 换行符     |   `\n`   |
| 横向制表符 |   `\t`   |
| 响铃       |   `\a`   |
| 纵向制表符 |   `\v`   |
| 退格符     |   `\b`   |
| 双引号     |   `\"`   |
| 单引号     |   `\'`   |
| 反斜线     |   `\\`   |
| 问号       |   `\?`   |
| 回车符     |   `\r`   |
| 进纸符     |   `\f`   |

5. **指定字面值的类型**
1. 字符和字符串字面值

| 前缀 | 含义                          | 类型     |
| ---- | ----------------------------- | -------- |
| u    | Unicode16字符                 | char16_t |
| U    | Unicode32字符                 | char32_t |
| L    | 宽字符                        | wchar_t  |
| u8   | UTF-8(仅用于字符串字面值常量) | char     |

2. 整型字面值

| 后缀     | 最小匹配类型 |
| -------- | ------------ |
| u或者U   | unsigned     |
| l或者L   | long         |
| ll或者LL | long long    |


3. 浮点型字面值

| 后缀   | 最小匹配类型 |
| ------ | ------------ |
| f或者F | float        |
| l或者L | long double  |

## 2.2 变量

***变量提供一个具名的、可供程序操作的存储空间，对C++程序员来说，“变量(variable)和对象(object)一般而言是相等的***

### 2.2.1 变量定义
`类型说明符 变量名 [= 初始值]`

- **初始值**：当对象在创建时获得一个特定的值，对象就被初始化了。
- **特别注意，初始化中的等号跟赋值中的等号完全不同。初始化的含义是在创建变量时赋予其一个初始值。而赋值的含义是把对象当前的值擦除，而以一个新值代替。**
- **列表初始化(C11新标准)**：`type variable_name{value}`, 当用于内置类型的变量时，如果使用列表初始化且初始值存在丢失信息的风险时，编译器会报错
- **默认初始化**:如果定义变量时没有指定初值，则变量被默认初始化。一个未被初始化的内置类型变量的值是未定义的；而每个类各自决定其初始化对象的方式
- 函数体外部定义的变量一般存放在固定地址中，而函数体内部定义的变量并非如此

### 2.2.2 变量的声明和定义

```C++
extern int i; //声明i
int j; //声明并定义j
extern double p = 3.1415 //定义
```

1. 为了支持分离式编译，C++语言将声明和定义区分开。**声明(declaration)** 使得名字为程序所知，一个文件如果使用别处定义的名字则必须包含那个名字的声明。而**定义(definition)** 负责创建与名字关联的实体。
2. 如果想声明一个变量需要在变量名前添加关键字`extern`,extern语句如果包含初始化就不再是声明，而是变成了定义
3. 变量只能被定义一次，但可以多次声明

### 2.2.3 标识符

1. C++的标识符由数字、字母、下划线组成，其中必须以字母或下划线开头，标识符对长度没有限制但对大小写敏感;
2. 不能使用C++关键字、不能出现两个连续的下划线、不能以下划线紧连大写字母、定义在函数体外的标识符不能以下划线开头
2. 变量命名规范
	1. 标识符要能体现实际含义
	2. 变量名一般用小写字母，不能使用形如Index或者INDEX
	3. 用户自定的类型一般以大写字母开头，如Sale_item
	4. 如果标识符由多个单词组成，则单词之间应该有明显区分，如student_loan或StudentLoan

### 2.2.4 名字的作用域

在程序中，名字指向一个特定的实体：变量、函数、类型等，而**作用域(scope)** 限制了名字的有效区域，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端结束。作用域以花括号分隔。

**全局作用域和块作用域**
	1. 定义在所有花括号之外的名字具有全局作用域，全局作用域的名字在整个程序内部都可使用
	2. 定义在花括号之内的名字具有块作用域，只能在块内起作用，

**嵌套作用域**
	作用域能够彼此包含，称为**内层作用域**和**外层作用域**，在外层作用域定义的名字内层作用域可以使用，而在内层作用域定义的名字外层则不可使用，在内层作用域定义的同名局部变量会覆盖外层的变量

**如果函数可能使用到某个全局变量，则不宜在定义一个同名的局部变量**

## 2.3 复合类型

***基于其他类型定义的类型称为复合类型***

### 2.3.1 引用

**引用(reference)** 为对象起了另一个名字，写法为在类型名前加上`&`符
```C++
	int val = 10;
	int &refval = val;
```

- **要点**
		1. 不存在空引用。引用必须连接到一块合法的内存。
		2. 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
		3. 引用必须在创建时被初始化。指针可以在任何时间被初始化。
		4. 引用不是一个对象，所以不存在引用的引用
		5. 引用的类型要和与之绑定的对象严格匹配，而且引用只能绑定在对象上。不能是字面值

### 2.3.2 指针

1. **指针(point)** 是指向另一种类型的复合类型，指针本身就是一个对象，且无需在定义时赋初值。**但是未初始化的指针的值是未定义的**
2. 定义指针的方法为：`int *p;`[^1]
2. 指针储存的是对象的地址，可以利用取地址符`&`获取对象的地址:`int *p = &val`
3. 利用指针访问对象：`int val = *p`,此时的`*`号称为解引用符，解引用操作只适用于那些指向了对象的指针
4. **空指针(null point)** 不指向任何对象：`int *p = nullptr`[^2]
5. **指针的值应属于下列四种状态之一**
		1. 指向一个对象
		2. 指向紧邻对象所占空间的下一个位置
		3. 空指针，意味着指针没有指向任何对象
		4. 无效指针，上述情况之外的其他值。试图访问无效指针将引发错误
6. **指针和引用的区别**：指针和引用都能提供对其他对象的间接访问，引用并非一个对象，一旦定义了引用就无法使其再绑定另一个对象。但是指针是对象，而且指针的指向可以被修改
7. **void\* 指针** :`void*`是一种特殊类型的指针，可以存放任意对象的地址，但是可用的操作比较有限，并不能直接操作`void*`指针的所指的对象，以`void*`的视角来看内存空间也仅仅是内存空间，没法访问内存空间中所存储的对象
8. 指向指针的指针：`int **p`,通过`*`的个数可以确定指针的级别
9. 指向指针的引用：指针是一个对象，所以定义指向指针的引用，反之引用不是一个对象，所以不存在指向引用的指针。`int *p = &u=i; int &ref = p;`

***建议初始化所有指针，如果可能，尽量在定义了对象之后再定义它的的指针***

## 2.4 const限定符
***利用`const`关键字来定义一个常量。因为常量不能被修改，所以`const`对象一旦创建后其值就不能再改变，所以const对象必须初始化***

### 2.4.1 const的引用

1. 默认状态下const对象仅在文件内有效: 在编译的过程中，编译器会将所有的const对象替换成对应的值，为了执行上述替换，编译器必须知道const对象的初始值，那么在用到该对象的文件中必须有对它的定义，所以在C++中const对象被设定为仅在文件内有效。如果要使const对象在文件间共享，则需要在变量的定义前加`extern`关键字
2. const的引用：对常量的引用不能被用作修改他所绑定的对象
	```C++
		const int cvalue = 19;
		const int &rc = cvalue;
	```
3. 默认情况下，引用的类型必须和所引用的对象保持一致，但是有两个例外，
	1. 第一个例外是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式能够转换成引用的类型，尤其是允许为一个常量引用绑定一个非常量的对象、字面值、一般表达式
	```C++
		double dval = 3.14;
		const int &ri = dval;
		//  此时ri引用的是一个int型的数，但是dval却是一个双精度浮点型的数，为了保证ri绑定的是一个整数，编译器进行了替换
		const int temp = dval;
		const int &ri = temp;
		//  在这种情况下ri绑定的是一个**临时量对象**，所谓临时量对象就是编译器需要一个临时空间来暂存表达式的求值结果
	```
	2. 当ri不是常量时，意味着可以通过ri改变所引用对象的值，但是ri引用的是一个临时量而非dval，既然创建了引用就是想通过引用修改所指向的对象的值，但是这种状况是无法修改的，所以C++将此类行为归为非法
3. ***注意：对const的引用仅对引用可参与的操作做了限定，而对所引用的对象本身是不是一个常量未作限定，因此对象可以是非常量，可以修改对象本身的值***

### 2.4.2 指针和const

- 与常量引用类似，也可以令指针指向常量，**指向常量的指针**不能用于改变其所指向的对象的值，指向常量的指针并没有规定其所指的对象必须是一个常量，只是不能通过该指针去改变所指对象的值，但是要想储存常量对象的地址，只能使用指向常量的指针
- 指针本身也是对象，所以可以令指针本身是常量，称为**常量指针(const pointer)**，把`*`放在const之前用来说明指针本身是一个常量，不能修改指针中所存储的地址， 也就是不能修改指针的指向，指针本身是一个常量并不意味这不能通过指针修改其所指的对象的值
```C++
	int val = 1;    //定义一个对象
	const int cval = 10;    //定义一个常量，其值不可修改
	const int *ptr = val;   //指向常量的指针，不能通过指针修改所指对象的值
	int *const ptr` = val;   //常量指针，不能修改指针的指向，但是可以修改所指对象的值
```

### 2.4.3 顶层const
**顶层const**表示指针本身是一个常量，即常量指针。**底层const**表示指针所指的对象是一个常量，const修饰的普通常量也是顶层const

### 2.4.4 constexpr和常量表达式
- **常量表达式(const expression)** 是指值不会改变的并且在编译过程就会得到计算结果的表达式。字面值、用常量表达式初始化的const对象也是常量表达式
- **constexpr** 变量：将变量声明为constexpr类型以便由编译器来验证变量的值是不是一个常量表达式
- 一般来说，如果你认定变量是一个常量表达式，那就声明为constexpr类型
- **字面值类型**：常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制，因为这些类型比较简单、值也显而易见，所有就把他们称为字面值类型。算术类型、引用、指针都属于此类，类类型则不属于字面值类型
- 注意：定义一个指针为constexpr类型，仅对指针本身有效，与指针指向的值无关
  
## 2.5 处理类型

### 2.5.1 类型别名
**类型别名(type alias)**: 用来简化复杂的类型名，两种方法创建类型别名
- 使用关键字`typedef`， 使用typedef定义的不再是变量而是类型别名
```C++
	typedef int zhengshu;    //zhengshu是int的别名
	typedef int* zhizhen;             //zhizhen是int*的别名
```
- 使用别名声明来定义类型的别名
```C++
	using zhegnshu = int;   //zhengshu是int的别名
	using zhizhen = int*;
```
- 易错点
```C++
	typedef char *pstring;
	const pstring cstr = nullptr;   //此时const修饰的是指向char的指针，也就是cstr是常量指针
```
### 2.5.2 auto类型说明符
- **auto**让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值
```C++
	auto i = 10;
	auto b = 3.15;
	auto c = `c`;
```
- auto会忽略顶层const,但底层const会保留
```C++
	const int i = 10;   //i是一个顶层const
	int j = 10;
	const int* p = &j    //p是一个底层const
	auto ai = i;       //i的顶层特性会被忽略
	auto ap = p;    //p的底层特性会被保留
```

### 2.5.3 decltype类型指示符

  - 类型说明符**decltype**会选择并返回操作数的数据类型，在此过程中编译器分析表达式并得到他的类型，却并不实际计算表达式的值
  - 如果decltye使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）
  - **注意**：decltype((variable))双层括号的结果永远是引用，而decltype(variable)结果只有当variable本身是引用是才是引用
```C++
	decltype( f() ) sum = x;     //sum的类型就是f()的返回类型
	int x = 10;
	int i  =10;
	const int ci = 100;
	int &ri = x;
	decltype(x) y = 20;    //y的类型就是x的类型
	decltype(ci) di = 2;    //di的类型就是ci的类型，并且因为ci是常量，所以di必须初始化
	decltype(ri) dri = x;    //dri就是x的引用
	decltype((x)) d = i;    //双层括号表示引用，此时d是int&类型
```

## 2.6 自定义数据结构
- **数据结构**：就是把一组相关的数据元素组织起来然后使用他们的策略和方法
- C++以类的形式自定义数据结构，类中包含属性和方法。属性就是数据元素，方法就是函数
- 在C++中类和结构体的区别
	- 类的关键字是`class`，结构体的关键字是`struct`
	- class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。
	- 从 class 继承默认是 private 继承，而从 struct 继承默认是 public 继承。
	- class 可以定义模板，而 struct 不可以。
	- C与C++结构体中前者不能有函数，后者可以有。
- 类的数据成员：类的数据成员定义了类的对象的具体内容，每个对象都有自己的一份数据成员拷贝，C++11标准中可以为数据成员提供一个**类内初始值**，以便在创建对象时初始化对象成员
  
### 2.6.1 定义一个数据结构
```C++
	struct type_name{
		member_type1 member_name1;
		member_type2 member_name2;
		.....
		member_function1();
		member_function2();
		......
	}object_name;   //结构体定义
	
	struct type_name object_name;   //结构体声明
	typedef struct type_name object_name2;    //C98及以前
```
- 注意事项1：**type_name** 是结构体类型的名称，`member_type1 member_name1` 是标准的变量定义，比如 `int i;` 或者 `float f;`或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。
- 注意事项2：在C中定义结构体变量需要使用`typedef`（C98以前），C++中不需要
- 注意事项2：C++在声明一个结构体变量时使用`typedef`带来的影响
	- 第一是不用 typedef：object_names 就相当于一个变量了，可以直接调用结构体中的内容
	- 第二种是用 typedef：object_names 部分是个结构体类型，在调用结构体之前必须创建结构体的变量
- 注意事项3：类右侧表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名，以示对该类型变量的定义
### 2.6.2 使用一个数据结构
- 通过成员访问运算符`.`来访问结构的成员
- `.`和`->`的不同：用结构体定义了一个实体，那么这个实体要访问他里面的成员，就用点操作符，如果用结构体定义的是一个结构指针，那么要访问他里面的成员就用箭头运算符。

  ### 2.6.3 使用头文件
  C++程序都是分离式编译，所有的预处理文件、常量、函数声明、类定义都放在头文件中
  - 确保头文件多次包含仍能安全工作的常用技术是**预处理器(preprocessor)**，预处理器是在编译之前执行的一段程序，以`#`开头
  - 使用头文件保护符来防止重复包含的发生
```C++
	#ifdef HEADNAME_H
	#define HEADNAME_H
	......
	#endif
```
  
  - 如果`#ifdef`为真，就执行接下来的语句直到`#endif`为止，否则就跳过
  - **无论头文件有没有被使用，头文件保护符都必须要有，且养成习惯**
  
  
  
  
  
  
  
  ![vector和数组](https://pan-yz.chaoxing.com/thumbnail/0,0,0/0ee2faa147d1e81564faed28e44245d2)
  
  
  
  
  

**关键概念**

1. 静态类型

C++是一种**静态类型(statically typed)**语言，其含义是在编译阶段检查类型。其中检查类型的过程称为**类型检查(type checking)**.在使用变量前声明类型有助于编译器发现问题

2. 在对象第一次被使用的地方附近定义它是一种好的选择

  
  

[^1]:`int *p` 强调变量具有复合类型;`int* p`这样写强调定义了一种复合类型
[^2]:`nullptr` 是一种特殊类型的字面值，他可以被转化为任意其他的指针类型，而`NULL`是一种预处理变量，在头文件`cstdlib`中定义，它的值就是0，在C++中最好使用nullptr,**尽量避免使用NULL**







